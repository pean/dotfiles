FUNCTION  GetVimIndent()
Called 7 times
Total time:   0.001825
 Self time:   0.000397

count  total (s)   self (s)
    7              0.000097   let ignorecase_save = &ignorecase
    7              0.000024   try
    7              0.000087     let &ignorecase = 0
    7   0.001516   0.000088     return GetVimIndentIntern()
                              finally
    7              0.000051     let &ignorecase = ignorecase_save
    7              0.000011   endtry

FUNCTION  airline#extensions#quickfix#inactive_qf_window()
Called 3 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    3              0.000018   if getbufvar(a:2.bufnr, '&filetype') is# 'qf' && !empty(airline#util#getwinvar(a:2.winnr, 'quickfix_title', ''))
                                call setwinvar(a:2.winnr, 'airline_section_c', '[%{get(w:, "quickfix_title", "")}] %f %m')
                              endif

FUNCTION  <SNR>40_buffer_commit()
Called 2 times
Total time:   0.000191
 Self time:   0.000050

count  total (s)   self (s)
    2   0.000189   0.000048   return matchstr(self.spec(),'^fugitive://.\{-\}//\zs\w*')

FUNCTION  1()
Called 25 times
Total time:   0.000787
 Self time:   0.000607

count  total (s)   self (s)
   25              0.000042     let prependCWD = 0
   25   0.000263   0.000083     if nerdtree#runningWindows()
                                    let prependCWD = a:str !~# '^.:\(\\\|\/\)' && a:str !~# '^\(\\\\\|\/\/\)'
                                else
   25              0.000157         let prependCWD = a:str !~# '^/'
   25              0.000020     endif
                            
   25              0.000042     let toReturn = a:str
   25              0.000025     if prependCWD
                                    let toReturn = getcwd() . s:Path.Slash() . a:str
                                endif
                            
   25              0.000030     return toReturn

FUNCTION  airline#util#exec_funcrefs()
Called 8 times
Total time:   0.006418
 Self time:   0.000454

count  total (s)   self (s)
   34              0.000060     for Fn in a:list
   34   0.006216   0.000253       let code = call(Fn, a:000)
   34              0.000042       if code != 0
    8              0.000009         return code
                                  endif
   26              0.000024     endfor
                                return 0

FUNCTION  RailsDetect()
Called 2 times
Total time:   0.000332
 Self time:   0.000332

count  total (s)   self (s)
    2              0.000009   if exists('b:rails_root')
                                return 1
                              endif
    2              0.000044   let fn = fnamemodify(a:0 ? a:1 : expand('%'), ':p')
    2              0.000017   if fn =~# ':[\/]\{2\}'
                                return 0
                              endif
    2              0.000010   if !isdirectory(fn)
    2              0.000009     let fn = fnamemodify(fn, ':h')
    2              0.000002   endif
    2              0.000203   let file = findfile('config/environment.rb', escape(fn, ', ').';')
    2              0.000010   if !empty(file) && isdirectory(fnamemodify(file, ':p:h:h') . '/app')
                                let b:rails_root = fnamemodify(file, ':p:h:h')
                                return 1
                              endif

FUNCTION  gitgutter#utility#filename()
Called 12 times
Total time:   0.000074
 Self time:   0.000074

count  total (s)   self (s)
   12              0.000064   return fnamemodify(s:file, ':t')

FUNCTION  gitgutter#utility#highlight_name_for_change()
Called 96 times
Total time:   0.000625
 Self time:   0.000625

count  total (s)   self (s)
   96              0.000200   if a:text ==# 'added'
   84              0.000125     return 'GitGutterLineAdded'
                              elseif a:text ==# 'removed'
                                return 'GitGutterLineRemoved'
                              elseif a:text ==# 'removed_first_line'
                                return 'GitGutterLineRemovedFirstLine'
                              elseif a:text ==# 'modified'
   12              0.000019     return 'GitGutterLineModified'
                              elseif a:text ==# 'modified_removed'
                                return 'GitGutterLineModifiedRemoved'
                              endif

FUNCTION  gitgutter#utility#command_in_directory_of_file()
Called 13 times
Total time:   0.000476
 Self time:   0.000181

count  total (s)   self (s)
   13   0.000467   0.000172   return 'cd '.gitgutter#utility#shellescape(gitgutter#utility#directory_of_file()).' && '.a:cmd

FUNCTION  gitgutter#process_buffer()
Called 23 times
Total time:   0.152312
 Self time:   0.004039

count  total (s)   self (s)
   23   0.001591   0.000272   call gitgutter#utility#use_known_shell()
                            
   23   0.000836   0.000221   call gitgutter#utility#set_buffer(a:bufnr)
   23   0.002998   0.000154   if gitgutter#utility#is_active()
   21              0.000069     if g:gitgutter_sign_column_always
   21   0.001217   0.000222       call gitgutter#sign#add_dummy_sign()
   21              0.000023     endif
   21              0.000040     try
   21   0.000345   0.000105       if !a:realtime || gitgutter#utility#has_fresh_changes()
   12   0.141436   0.000457         let diff = gitgutter#diff#run_diff(a:realtime || gitgutter#utility#has_unsaved_changes(), 0)
   12              0.000061         if diff != 'async'
                                      call gitgutter#handle_diff(diff)
                                    endif
   12              0.000011       endif
   21              0.000036     catch /diff failed/
                                  call gitgutter#debug#log('diff failed')
                                  call gitgutter#hunk#reset()
                                endtry
   21   0.001828   0.001440     execute "silent doautocmd" s:nomodeline "User GitGutter"
   21              0.000042   else
    2   0.000130   0.000015     call gitgutter#hunk#reset()
    2              0.000002   endif
                            
   23   0.000996   0.000219   call gitgutter#utility#restore_shell()

FUNCTION  gitgutter#async#handle_diff_job_nvim()
Called 24 times
Total time:   0.053261
 Self time:   0.003376

count  total (s)   self (s)
   24   0.002195   0.000731   call gitgutter#debug#log('job_id: '.a:job_id.', event: '.a:event.', buffer: '.self.buffer)
                            
   24              0.000090   let job_bufnr = self.buffer
   24              0.000097   if bufexists(job_bufnr)
   24   0.000310   0.000218     let current_buffer = gitgutter#utility#bufnr()
   24   0.000813   0.000201     call gitgutter#utility#set_buffer(job_bufnr)
                            
   24              0.000077     if a:event == 'stdout'
                                  " a:data is a list
   12   0.000220   0.000093       call s:job_finished(a:job_id)
   12   0.001824   0.000083       if gitgutter#utility#is_active()
   12   0.045572   0.000327         call gitgutter#handle_diff(gitgutter#utility#stringify(a:data))
   12              0.000015       endif
                            
   12              0.000019     elseif a:event == 'exit'
                                  " If the exit event is triggered without a preceding stdout event,
                                  " the diff was empty.
   12   0.000172   0.000093       if s:is_job_started(a:job_id)
                                    if gitgutter#utility#is_active()
                                      call gitgutter#handle_diff("")
                                    endif
                                    call s:job_finished(a:job_id)
                                  endif
                            
   12              0.000017     else  " a:event is stderr
                                  call gitgutter#hunk#reset()
                                  call s:job_finished(a:job_id)
                            
                                endif
                            
   24   0.000671   0.000147     call gitgutter#utility#set_buffer(current_buffer)
   24              0.000036   else
                                call s:job_finished(a:job_id)
                              endif

FUNCTION  <SNR>109_SetupCount()
Called 560 times
Total time:   0.009579
 Self time:   0.009579

count  total (s)   self (s)
  560              0.001822     if !has_key(g:ale_buffer_info, a:buffer)
                                    " Linters have not been run for the buffer yet, so stop here.
                                    return 0
                                endif
                            
                                " Cache is cold, so manually ask for an update.
  560              0.002098     if !has_key(g:ale_buffer_info[a:buffer], 'count')
                                    call ale#statusline#Update(a:buffer, g:ale_buffer_info[a:buffer].loclist)
                                endif
                            
  560              0.000547     return 1

FUNCTION  gitgutter#utility#system()
Called 1 time
Total time:   0.019982
 Self time:   0.019892

count  total (s)   self (s)
    1   0.000076   0.000013   call gitgutter#debug#log(a:cmd, a:000)
                            
    1   0.000033   0.000005   if gitgutter#utility#using_xolox_shell()
                                let options = {'command': a:cmd, 'check': 0}
                                if a:0 > 0
                                  let options['stdin'] = a:1
                                endif
                                let ret = xolox#misc#os#exec(options)
                                let output = join(ret.stdout, "\n")
                                let s:exit_code = ret.exit_code
                              else
    1              0.019839     silent let output = (a:0 == 0) ? system(a:cmd) : system(a:cmd, a:1)
    1              0.000005   endif
    1              0.000005   return output

FUNCTION  ale#linter#Get()
Called 38 times
Total time:   0.005098
 Self time:   0.004054

count  total (s)   self (s)
   38              0.000101     let l:combined_linters = []
                            
                                " Handle dot-seperated filetypes.
   74              0.000401     for l:original_filetype in split(a:original_filetypes, '\.')
   36   0.000805   0.000264         let l:filetype = ale#linter#ResolveFiletype(l:original_filetype)
                            
                                    " Try and get a list of linters to run, using the original file type,
                                    " not the aliased filetype. We have some linters to limit by default,
                                    " and users may define their own list of linters to run.
   36              0.000270         let l:linter_names = get(   g:ale_linters,   l:original_filetype,   get(       s:default_ale_linters,       l:original_filetype,       'all'   ))
                            
   36   0.000767   0.000263         let l:all_linters = ale#linter#GetAll(l:filetype)
   36              0.000080         let l:filetype_linters = []
                            
   36              0.000171         if type(l:linter_names) == type('') && l:linter_names ==# 'all'
   36              0.000093             let l:filetype_linters = l:all_linters
   36              0.000096         elseif type(l:linter_names) == type([])
                                        " Select only the linters we or the user has specified.
                                        for l:linter in l:all_linters
                                            if index(l:linter_names, l:linter.name) >= 0
                                                call add(l:filetype_linters, l:linter)
                                            endif
                                        endfor
                                    endif
                            
   36              0.000139         call extend(l:combined_linters, l:filetype_linters)
   36              0.000038     endfor
                            
   38              0.000067     return l:combined_linters

FUNCTION  gutentags#is_path_rooted()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000004   return !empty(a:path) && a:path[0] == '/'

FUNCTION  gitgutter#sign#remove_signs()
Called 12 times
Total time:   0.000400
 Self time:   0.000370

count  total (s)   self (s)
   12   0.000112   0.000082   let bufnr = gitgutter#utility#bufnr()
   12              0.000051   if a:all_signs && s:supports_star && empty(gitgutter#utility#getbufvar(bufnr, 'other_signs'))
                                let dummy_sign_present = gitgutter#utility#getbufvar(bufnr, 'dummy_sign')
                                execute "sign unplace * buffer=" . bufnr
                                if dummy_sign_present
                                  execute "sign place" s:dummy_sign_id "line=" . 9999 "name=GitGutterDummy buffer=" . bufnr
                                endif
                              else
   12              0.000031     for id in a:sign_ids
                                  execute "sign unplace" id
                                endfor
   12              0.000012   endif

FUNCTION  gitgutter#utility#dedup()
Called 8 times
Total time:   0.000201
 Self time:   0.000201

count  total (s)   self (s)
    8              0.000187   return filter(sort(a:list), 'index(a:list, v:val, v:key + 1) == -1')

FUNCTION  gitgutter#diff#process_hunk()
Called 12 times
Total time:   0.005615
 Self time:   0.001265

count  total (s)   self (s)
   12              0.000028   let modifications = []
   12              0.000031   let from_line  = a:hunk[0]
   12              0.000027   let from_count = a:hunk[1]
   12              0.000026   let to_line    = a:hunk[2]
   12              0.000025   let to_count   = a:hunk[3]
                            
   12   0.000116   0.000075   if gitgutter#diff#is_added(from_count, to_count)
                                call gitgutter#diff#process_added(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_added(to_count)
                            
                              elseif gitgutter#diff#is_removed(from_count, to_count)
                                call gitgutter#diff#process_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_removed(from_count)
                            
                              elseif gitgutter#diff#is_modified(from_count, to_count)
                                call gitgutter#diff#process_modified(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(to_count)
                            
                              elseif gitgutter#diff#is_modified_and_added(from_count, to_count)
   12   0.002814   0.000138     call gitgutter#diff#process_modified_and_added(modifications, from_count, to_count, to_line)
   12   0.000978   0.000135     call gitgutter#hunk#increment_lines_added(to_count - from_count)
   12   0.000750   0.000093     call gitgutter#hunk#increment_lines_modified(from_count)
                            
   12              0.000038   elseif gitgutter#diff#is_modified_and_removed(from_count, to_count)
                                call gitgutter#diff#process_modified_and_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(to_count)
                                call gitgutter#hunk#increment_lines_removed(from_count - to_count)
                            
                              endif
   12              0.000020   return modifications

FUNCTION  airline#check_mode()
Called 303 times
Total time:   0.270256
 Self time:   0.044590

count  total (s)   self (s)
  303              0.001824   let context = s:contexts[a:winnr]
                            
  303              0.001264   if get(w:, 'airline_active', 1)
  301              0.001156     let l:m = mode()
  301              0.000781     if l:m ==# "i"
   29              0.000070       let l:mode = ['insert']
   29              0.000043     elseif l:m ==# "R"
                                  let l:mode = ['replace']
                                elseif l:m =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
                                elseif l:m ==# "t"
                                  let l:mode = ['terminal']
                                else
  272              0.000871       let l:mode = ['normal']
  272              0.000310     endif
  301              0.001912     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
  301              0.000309   else
    2              0.000005     let l:mode = ['inactive']
    2              0.000009     let w:airline_current_mode = get(g:airline_mode_map, '__')
    2              0.000002   endif
                            
  303              0.001290   if g:airline_detect_modified && &modified
  141              0.000702     call add(l:mode, 'modified')
  141              0.000139   endif
                            
  303              0.000737   if g:airline_detect_paste && &paste
    1              0.000003     call add(l:mode, 'paste')
    1              0.000001   endif
                            
  303              0.004980   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
                              endif
                            
  303              0.000780   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
                              endif
                            
  303              0.000594   if &readonly || ! &modifiable
   21              0.000070     call add(l:mode, 'readonly')
   21              0.000016   endif
                            
  303              0.001829   let mode_string = join(l:mode)
  303              0.001759   if get(w:, 'airline_lastmode', '') != mode_string
   13   0.002435   0.000139     call airline#highlighter#highlight_modified_inactive(context.bufnr)
   13   0.223618   0.000248     call airline#highlighter#highlight(l:mode, context.bufnr)
   13              0.000061     let w:airline_lastmode = mode_string
   13              0.000015   endif
                            
  303              0.000429   return ''

FUNCTION  3()
Called 24 times
Total time:   0.001072
 Self time:   0.000706

count  total (s)   self (s)
   24   0.000329   0.000094     let self.cachedDisplayString = self.getLastPathComponent(1)
                            
   24              0.000024     if self.isExecutable
                                    let self.cachedDisplayString = self.cachedDisplayString . '*'
                                endif
                            
   24              0.000042     let self._bookmarkNames = []
   24   0.000210   0.000079     for i in g:NERDTreeBookmark.Bookmarks()
                                    if i.path.equals(self)
                                        call add(self._bookmarkNames, i.name)
                                    endif
                                endfor
   24              0.000036     if !empty(self._bookmarkNames)
                                    let self.cachedDisplayString .= ' {' . join(self._bookmarkNames) . '}'
                                endif
                            
   24              0.000022     if self.isSymLink
                                    let self.cachedDisplayString .=  ' -> ' . self.symLinkDest
                                endif
                            
   24              0.000022     if self.isReadOnly
                                    let self.cachedDisplayString .=  ' ['.g:NERDTreeGlyphReadOnly.']'
                                endif

FUNCTION  <SNR>80_update_git_branch()
Called 560 times
Total time:   0.167487
 Self time:   0.033929

count  total (s)   self (s)
  560              0.001120   if !s:has_fugitive
                                let s:vcs_config['git'].branch = ''
                                return
                              endif
                            
  560   0.137229   0.003671   let name = fugitive#head(7)
  560              0.001477   if empty(name)
                                if has_key(s:git_dirs, a:path)
                                  let s:vcs_config['git'].branch = s:git_dirs[a:path]
                                  return
                                endif
                            
                                let dir = fugitive#extract_git_dir(a:path)
                                if empty(dir)
                                  let name = ''
                                else
                                  try
                                    let line = join(readfile(dir . '/HEAD'))
                                    if strpart(line, 0, 16) == 'ref: refs/heads/'
                                      let name = strpart(line, 16)
                                    else
                                      " raw commit hash
                                      let name = strpart(line, 0, 7)
                                    endif
                                  catch
                                    let name = ''
                                  endtry
                                endif
                              endif
                            
  560              0.002337   let s:git_dirs[a:path] = name
  560              0.002349   let s:vcs_config['git'].branch = name

FUNCTION  <SNR>76_is_excluded_window()
Called 8 times
Total time:   0.000402
 Self time:   0.000402

count  total (s)   self (s)
    8              0.000021   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
                              endfor
                            
   32              0.000045   for matchw in g:airline_exclude_filenames
   24              0.000155     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
                                endif
   24              0.000015   endfor
                            
    8              0.000014   if g:airline_exclude_preview && &previewwindow
                                return 1
                              endif
                            
    8              0.000007   return 0

FUNCTION  <SNR>85_CheckDefined()
Called 710 times
Total time:   0.012049
 Self time:   0.012049

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
  710              0.002466   if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
                              endif
  710              0.002164   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
  710              0.000986     return a:colors
                              endif
                            
                              for val in a:colors
                                if !empty(val) && val !=# 'NONE'
                                  return a:colors
                                endif
                              endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
                              let fg = g:airline#highlighter#normal_fg_hi
                              let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                              if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
                              return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  <SNR>43_invoke_funcrefs()
Called 8 times
Total time:   0.042630
 Self time:   0.000460

count  total (s)   self (s)
    8   0.000287   0.000047   let builder = airline#builder#new(a:context)
    8   0.006540   0.000122   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
    8              0.000011   if err == 1
    8   0.035595   0.000083     let a:context.line = builder.build()
    8              0.000060     let s:contexts[a:context.winnr] = a:context
    8              0.000111     call setwinvar(a:context.winnr, '&statusline', '%!airline#statusline('.a:context.winnr.')')
    8              0.000009   endif

FUNCTION  airline#themes#get_highlight()
Called 262 times
Total time:   0.033649
 Self time:   0.002917

count  total (s)   self (s)
  262   0.033525   0.002793   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  <SNR>65_dopopd()
Called 2 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    2              0.000008   if !exists('w:fzf_prev_dir') || exists('*haslocaldir') && !haslocaldir()
    2              0.000001     return
                              endif
                              execute 'lcd' s:escape(w:fzf_prev_dir)
                              unlet w:fzf_prev_dir

FUNCTION  <SNR>106_try_cmd()
Called 2 times
Total time:   0.269285
 Self time:   0.269285

count  total (s)   self (s)
    2              0.000019   let argv = split(a:cmd, " ")
    2              0.269179   let out = a:0 ? systemlist(argv, a:1, 1) : systemlist(argv, [''], 1)
    2              0.000019   if v:shell_error
                                if !exists('s:did_error_try_cmd')
                                  echohl WarningMsg
                                  echomsg "clipboard: error: ".(len(out) ? out[0] : '')
                                  echohl None
                                  let s:did_error_try_cmd = 1
                                endif
                                return 0
                              endif
    2              0.000003   return out

FUNCTION  gitgutter#sign#update_signs()
Called 12 times
Total time:   0.033443
 Self time:   0.000912

count  total (s)   self (s)
   12   0.011234   0.000127   call gitgutter#sign#find_current_signs()
                            
   12              0.000172   let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
   12   0.002312   0.000129   let obsolete_signs = gitgutter#sign#obsolete_gitgutter_signs_to_remove(new_gitgutter_signs_line_numbers)
                            
   12              0.000051   let flicker_possible = s:remove_all_old_signs && !empty(a:modified_lines)
   12              0.000019   if flicker_possible
                                call gitgutter#sign#add_dummy_sign()
                              endif
                            
   12   0.000507   0.000107   call gitgutter#sign#remove_signs(obsolete_signs, s:remove_all_old_signs)
   12   0.018957   0.000116   call gitgutter#sign#upsert_new_gitgutter_signs(a:modified_lines)
                            
   12              0.000024   if flicker_possible
                                call gitgutter#sign#remove_dummy_sign(0)
                              endif

FUNCTION  <SNR>76_sync_active_winnr()
Called 198 times
Total time:   0.002373
 Self time:   0.002373

count  total (s)   self (s)
  198              0.001473   if exists('#airline') && winnr() != s:active_winnr
                                call airline#update_statusline()
                              endif

FUNCTION  ale#statusline#Count()
Called 560 times
Total time:   0.019317
 Self time:   0.009738

count  total (s)   self (s)
  560              0.001916     if !exists('g:ale_buffer_info')
                                    return [0, 0]
                                endif
                            
  560   0.012441   0.002862     if !s:SetupCount(a:buffer)
                                    return [0, 0]
                                endif
                            
  560              0.001549     return g:ale_buffer_info[a:buffer].count

FUNCTION  airline#extensions#quickfix#apply()
Called 5 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
    5              0.000017   if &buftype == 'quickfix'
                                let w:airline_section_a = s:get_text()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
                              endif

FUNCTION  airline#highlighter#add_accent()
Called 2 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    2              0.000007   let s:accents[a:accent] = 1

FUNCTION  fugitive#buffer()
Called 2 times
Total time:   0.000167
 Self time:   0.000025

count  total (s)   self (s)
    2   0.000165   0.000024   return s:buffer(a:0 ? a:1 : '%')

FUNCTION  gitgutter#sign#find_current_signs()
Called 12 times
Total time:   0.011107
 Self time:   0.010252

count  total (s)   self (s)
   12   0.000084   0.000058   let bufnr = gitgutter#utility#bufnr()
   12              0.000028   let gitgutter_signs = {}  " <line_number (string)>: {'id': <id (number)>, 'name': <name (string)>}
   12              0.000026   let other_signs = []      " [<line_number (number),...]
   12              0.000025   let dummy_sign_placed = 0
                            
   12              0.000049   redir => signs
   12              0.000458     silent execute "sign place buffer=" . bufnr
   12              0.000056   redir END
                            
  117              0.000893   for sign_line in filter(split(signs, '\n')[2:], 'v:val =~# "="')
                                " Typical sign line:  line=88 id=1234 name=GitGutterLineAdded
                                " We assume splitting is faster than a regexp.
  105              0.001990     let components  = split(sign_line)
  105              0.000825     let name        = split(components[2], '=')[1]
  105              0.000593     if name =~# 'GitGutterDummy'
   12              0.000026       let dummy_sign_placed = 1
   12              0.000014     else
   93              0.000715       let line_number = str2nr(split(components[0], '=')[1])
   93              0.000449       if name =~# 'GitGutter'
   93              0.000705         let id = str2nr(split(components[1], '=')[1])
                                    " Remove orphaned signs (signs placed on lines which have been deleted).
                                    " (When a line is deleted its sign lingers.  Subsequent lines' signs'
                                    " line numbers are decremented appropriately.)
   93              0.000318         if has_key(gitgutter_signs, line_number)
                                      execute "sign unplace" gitgutter_signs[line_number].id
                                    endif
   93              0.000509         let gitgutter_signs[line_number] = {'id': id, 'name': name}
   93              0.000086       else
                                    call add(other_signs, line_number)
                                  endif
   93              0.000079     end
  105              0.000105   endfor
                            
   12   0.000424   0.000139   call gitgutter#utility#setbufvar(bufnr, 'dummy_sign', dummy_sign_placed)
   12   0.000480   0.000095   call gitgutter#utility#setbufvar(bufnr, 'gitgutter_signs', gitgutter_signs)
   12   0.000237   0.000078   call gitgutter#utility#setbufvar(bufnr, 'other_signs', other_signs)

FUNCTION  GetVimIndentIntern()
Called 7 times
Total time:   0.001428
 Self time:   0.001428

count  total (s)   self (s)
                              " Find a non-blank line above the current line.
    7              0.000054   let lnum = prevnonblank(v:lnum - 1)
                            
                              " If the current line doesn't start with '\' and below a line that starts
                              " with '\', use the indent of the line above it.
    7              0.000033   let cur_text = getline(v:lnum)
    7              0.000123   if cur_text !~ '^\s*\\'
    7              0.000072     while lnum > 0 && getline(lnum) =~ '^\s*\\'
                                  let lnum = lnum - 1
                                endwhile
    7              0.000009   endif
                            
                              " At the start of the file use zero indent.
    7              0.000014   if lnum == 0
                                return 0
                              endif
    7              0.000026   let prev_text = getline(lnum)
                            
                              " Add a 'shiftwidth' after :if, :while, :try, :catch, :finally, :function
                              " and :else.  Add it three times for a line that starts with '\' after
                              " a line that doesn't (or g:vim_indent_cont if it exists).
    7              0.000025   let ind = indent(lnum)
    7              0.000059   if cur_text =~ '^\s*\\' && v:lnum > 1 && prev_text !~ '^\s*\\'
                                if exists("g:vim_indent_cont")
                                  let ind = ind + g:vim_indent_cont
                                else
                                  let ind = ind + shiftwidth() * 3
                                endif
                              elseif prev_text =~ '^\s*aug\%[roup]\s\+' && prev_text !~ '^\s*aug\%[roup]\s\+[eE][nN][dD]\>'
                                let ind = ind + shiftwidth()
                              else
                                " A line starting with :au does not increment/decrement indent.
    7              0.000059     if prev_text !~ '^\s*au\%[tocmd]'
    7              0.000161       let i = match(prev_text, '\(^\||\)\s*\(if\|wh\%[ile]\|for\|try\|cat\%[ch]\|fina\%[lly]\|fu\%[nction]\|el\%[seif]\)\>')
    7              0.000013       if i >= 0
                            	let ind += shiftwidth()
                            	if strpart(prev_text, i, 1) == '|' && has('syntax_items') && synIDattr(synID(lnum, i, 1), "name") =~ '\(Comment\|String\)$'
                            	  let ind -= shiftwidth()
                            	endif
                                  endif
    7              0.000005     endif
    7              0.000005   endif
                            
                              " If the previous line contains an "end" after a pipe, but not in an ":au"
                              " command.  And not when there is a backslash before the pipe.
                              " And when syntax HL is enabled avoid a match inside a string.
    7              0.000101   let i = match(prev_text, '[^\\]|\s*\(ene\@!\)')
    7              0.000017   if i > 0 && prev_text !~ '^\s*au\%[tocmd]'
                                if !has('syntax_items') || synIDattr(synID(lnum, i + 2, 1), "name") !~ '\(Comment\|String\)$'
                                  let ind = ind - shiftwidth()
                                endif
                              endif
                            
                            
                              " Subtract a 'shiftwidth' on a :endif, :endwhile, :catch, :finally, :endtry,
                              " :endfun, :else and :augroup END.
    7              0.000091   if cur_text =~ '^\s*\(ene\@!\|cat\|fina\|el\|aug\%[roup]\s\+[eE][nN][dD]\)'
                                let ind = ind - shiftwidth()
                              endif
                            
    7              0.000013   return ind

FUNCTION  airline#parts#filetype()
Called 280 times
Total time:   0.002445
 Self time:   0.002445

count  total (s)   self (s)
  280              0.002227   return winwidth(0) < 90 && strlen(&filetype) > 3 ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '…' : '>') : &filetype

FUNCTION  airline#extensions#netrw#apply()
Called 5 times
Total time:   0.000111
 Self time:   0.000111

count  total (s)   self (s)
    5              0.000025   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
                              endif

FUNCTION  airline#parts#iminsert()
Called 280 times
Total time:   0.002190
 Self time:   0.002190

count  total (s)   self (s)
  280              0.000825   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
                              endif
  280              0.000274   return ''

FUNCTION  gitgutter#utility#use_known_shell()
Called 23 times
Total time:   0.001319
 Self time:   0.001319

count  total (s)   self (s)
   23              0.000136   if has('unix')
   23              0.000127     if &shell !=# 'sh'
   23              0.000235       let s:shell = &shell
   23              0.000090       let s:shellcmdflag = &shellcmdflag
   23              0.000094       let s:shellredir = &shellredir
   23              0.000186       let &shell = 'sh'
   23              0.000190       set shellcmdflag=-c
   23              0.000107       set shellredir=>%s\ 2>&1
   23              0.000043     endif
   23              0.000021   endif

FUNCTION  gitgutter#sign#next_sign_id()
Called 3 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    3              0.000012   let next_id = s:next_sign_id
    3              0.000009   let s:next_sign_id += 1
    3              0.000005   return next_id

FUNCTION  gitgutter#utility#not_git_dir()
Called 33 times
Total time:   0.002899
 Self time:   0.001152

count  total (s)   self (s)
   33   0.002875   0.001128   return gitgutter#utility#full_path_to_directory_of_file() !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  fugitive#detect()
Called 2 times
Total time:   0.003780
 Self time:   0.000718

count  total (s)   self (s)
    2              0.000017   if exists('b:git_dir') && (b:git_dir ==# '' || b:git_dir =~# '/$')
                                unlet b:git_dir
                              endif
    2              0.000005   if !exists('b:git_dir')
    1   0.000509   0.000013     let dir = fugitive#extract_git_dir(a:path)
    1              0.000003     if dir !=# ''
    1              0.000003       let b:git_dir = dir
    1              0.000001     endif
    1              0.000001   endif
    2              0.000007   if exists('b:git_dir')
    2              0.000017     if exists('#User#FugitiveBoot')
                                  try
                                    let [save_mls, &modelines] = [&mls, 0]
                                    doautocmd User FugitiveBoot
                                  finally
                                    let &mls = save_mls
                                  endtry
                                endif
    2              0.000008     if !exists('g:fugitive_no_maps')
    2              0.000047       cnoremap <buffer> <expr> <C-R><C-G> fnameescape(<SID>recall())
    2              0.000039       nnoremap <buffer> <silent> y<C-G> :call setreg(v:register, <SID>recall())<CR>
    2              0.000003     endif
    2   0.000198   0.000030     let buffer = fugitive#buffer()
    2              0.000108     if expand('%:p') =~# '://'
                                  call buffer.setvar('&path', s:sub(buffer.getvar('&path'), '^\.%(,|$)', ''))
                                endif
    2   0.000051   0.000036     if stridx(buffer.getvar('&tags'), escape(b:git_dir, ', ')) == -1
    2              0.000041       if filereadable(b:git_dir.'/tags')
                                    call buffer.setvar('&tags', escape(b:git_dir.'/tags', ', ').','.buffer.getvar('&tags'))
                                  endif
    2              0.000042       if &filetype !=# '' && filereadable(b:git_dir.'/'.&filetype.'.tags')
                                    call buffer.setvar('&tags', escape(b:git_dir.'/'.&filetype.'.tags', ', ').','.buffer.getvar('&tags'))
                                  endif
    2              0.000002     endif
    2              0.000004     try
    2              0.000039       let [save_mls, &modelines] = [&mls, 0]
    2   0.000963   0.000025       call s:define_commands()
    2   0.001535   0.000089       doautocmd User Fugitive
    2              0.000004     finally
    2              0.000022       let &mls = save_mls
    2              0.000003     endtry
    2              0.000002   endif

FUNCTION  gitgutter#diff#is_added()
Called 12 times
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
   12              0.000032   return a:from_count == 0 && a:to_count > 0

FUNCTION  <SNR>80_format_name()
Called 6 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    6              0.000009     return a:name

FUNCTION  12()
Called 24 times
Total time:   0.001241
 Self time:   0.000169

count  total (s)   self (s)
   24              0.000039     if self.cachedDisplayString ==# ""
   24   0.001140   0.000069         call self.cacheDisplayString()
   24              0.000015     endif
                            
   24              0.000025     return self.cachedDisplayString

FUNCTION  14()
Called 25 times
Total time:   0.000601
 Self time:   0.000442

count  total (s)   self (s)
   25   0.000230   0.000071     if nerdtree#runningWindows()
                                    if a:fullpath =~ '^\(\\\\\|\/\/\)'
                                        "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
                                        let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
                                        let self.drive = substitute(self.drive, '/', '\', "g")
                                    else
                                        let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
                                    endif
                                else
   25              0.000065         let self.drive = ''
   25              0.000018     endif
                            

FUNCTION  16()
Called 1 time
Total time:   0.000012
 Self time:   0.000006

count  total (s)   self (s)
    1   0.000008   0.000002     if nerdtree#runningWindows()
                                    return " `\|\"#%&,?()\*^<>$"
                                endif
                            
    1              0.000001     return " \\`\|\"#%&,?()\*^<>[]$"

FUNCTION  19()
Called 213 times
Total time:   0.002156
 Self time:   0.002156

count  total (s)   self (s)
  213              0.000363     if empty(self.pathSegments)
                                    return ''
                                endif
  213              0.000392     let toReturn = self.pathSegments[-1]
  213              0.000281     if a:dirSlash && self.isDirectory
   21              0.000059         let toReturn = toReturn . '/'
   21              0.000015     endif
  213              0.000212     return toReturn

FUNCTION  107()
Called 17 times
Total time:   0.001120
 Self time:   0.000106

count  total (s)   self (s)
   17   0.001114   0.000100     return self.path.flagSet.renderToString() . self.path.displayString()

FUNCTION  108()
Called 1 time
Total time:   0.000354
 Self time:   0.000014

count  total (s)   self (s)
    1   0.000353   0.000013     return self.path.str() ==# a:treenode.path.str()

FUNCTION  ale#ShouldDoNothing()
Called 247 times
Total time:   0.023846
 Self time:   0.007122

count  total (s)   self (s)
                                " Do nothing for blacklisted files
                                " OR if ALE is running in the sandbox
  247   0.022952   0.006227     return index(g:ale_filetype_blacklist, &filetype) >= 0   || (exists('*getcmdwintype') && !empty(getcmdwintype()))   || ale#util#InSandbox()

FUNCTION  <SNR>81_count()
Called 560 times
Total time:   0.031528
 Self time:   0.012210

count  total (s)   self (s)
  560              0.002413   let l:buf = bufnr('%')
  560   0.022409   0.003092   let l:count = ale#statusline#Count(l:buf)
  560              0.001724   if type(l:count) ==# type(0)
                                let l:count = 0
                              else
  560              0.001425     let l:count = l:count[a:index]
  560              0.000481   endif
                            
  560              0.000741   return l:count

FUNCTION  <SNR>85_get_array()
Called 1028 times
Total time:   0.008307
 Self time:   0.008307

count  total (s)   self (s)
 1028              0.007785   return g:airline_gui_mode ==# 'gui' ? [ a:fg, a:bg, '', '', join(a:opts, ',') ] : [ '', '', a:fg, a:bg, join(a:opts, ',') ]

FUNCTION  20()
Called 24 times
Total time:   0.002236
 Self time:   0.001321

count  total (s)   self (s)
   24              0.000030     let i = 0
  109              0.000192     while i < len(g:NERDTreeSortOrder)
   92   0.001525   0.000609         if  self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
    7              0.000008             return i
                                    endif
   85              0.000107         let i = i + 1
   85              0.000071     endwhile
   17              0.000022     return s:NERDTreeSortStarIndex

FUNCTION  21()
Called 348 times
Total time:   0.008062
 Self time:   0.005519

count  total (s)   self (s)
  348              0.000974     if !exists("self._sortKey")
   24   0.000435   0.000129         let path = self.getLastPathComponent(1)
   24              0.000035         if !g:NERDTreeSortHiddenFirst
                                        let path = substitute(path, '^[._]', '', '')
                                    endif
   24              0.000032         if !g:NERDTreeCaseSensitiveSort
   24              0.000059             let path = tolower(path)
   24              0.000017         endif
   24   0.002404   0.000168         let self._sortKey = printf(s:sortKeyFormat, self.getSortOrderIndex()) . path
   24              0.000018     endif
                            
  348              0.000343     return self._sortKey

FUNCTION  24()
Called 48 times
Total time:   0.003571
 Self time:   0.001683

count  total (s)   self (s)
                                "filter out the user specified paths to ignore
   48   0.000189   0.000125     if a:nerdtree.ui.isIgnoreFilterEnabled()
   96              0.000115         for i in g:NERDTreeIgnore
   48   0.001606   0.000150             if self._ignorePatternMatches(i)
                                            return 1
                                        endif
   48              0.000033         endfor
                            
   48   0.000390   0.000143         for callback in g:NERDTree.PathFilters()
                                        if {callback}({'path': self, 'nerdtree': a:nerdtree})
                                            return 1
                                        endif
                                    endfor
   48              0.000031     endif
                            
                                "dont show hidden files unless instructed to
   48   0.000212   0.000151     if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
                                    return 1
                                endif
                            
   48   0.000202   0.000141     if a:nerdtree.ui.getShowFiles() ==# 0 && self.isDirectory ==# 0
                                    return 1
                                endif
                            
   48              0.000033     return 0

FUNCTION  25()
Called 48 times
Total time:   0.001455
 Self time:   0.001023

count  total (s)   self (s)
   48              0.000067     let pat = a:pattern
   48              0.000132     if strpart(pat,len(pat)-7) == '[[dir]]'
                                    if !self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-7)
                                elseif strpart(pat,len(pat)-8) == '[[file]]'
                                    if self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-8)
                                endif
                            
   48   0.000667   0.000235     return self.getLastPathComponent(0) =~# pat

FUNCTION  112()
Called 98 times
Total time:   0.000133
 Self time:   0.000133

count  total (s)   self (s)
   98              0.000103     return self._nerdtree

FUNCTION  116()
Called 1 time
Total time:   0.000375
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000008   0.000005     if !g:NERDTree.ExistsForBuf()
                                    throw "NERDTree.NoTreeError: No tree exists for the current buffer"
                                endif
                            
    1   0.000363   0.000008     return self.equals(self.getNerdtree().root)

FUNCTION  117()
Called 24 times
Total time:   0.000979
 Self time:   0.000633

count  total (s)   self (s)
   24              0.000029     if a:path.isDirectory
    7   0.000519   0.000173         return g:NERDTreeDirNode.New(a:path, a:nerdtree)
                                else
   17              0.000233         let newTreeNode = copy(self)
   17              0.000036         let newTreeNode.path = a:path
   17              0.000030         let newTreeNode.parent = {}
   17              0.000031         let newTreeNode._nerdtree = a:nerdtree
   17              0.000020         return newTreeNode
                                endif

FUNCTION  airline#util#system()
Called 4 times
Total time:   1.605044
 Self time:   1.604954

count  total (s)   self (s)
    4              0.000050     let l:config = { 'buf': '', 'on_stdout': function('s:system_job_handler'), }
    4              0.013507     let l:id = jobstart(a:cmd, l:config)
    4              0.000044     if l:id < 1
                                  return system(a:cmd)
                                endif
    4   1.591278   1.591188     call jobwait([l:id])
    4              0.000068     return l:config.buf

FUNCTION  airline#util#wrap()
Called 2263 times
Total time:   0.020429
 Self time:   0.020429

count  total (s)   self (s)
 2263              0.011447   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
 2263              0.002953   return a:text

FUNCTION  <SNR>40_define_commands()
Called 2 times
Total time:   0.000938
 Self time:   0.000938

count  total (s)   self (s)
   56              0.000116   for command in s:commands
   54              0.000725     exe 'command! -buffer '.command
   54              0.000072   endfor

FUNCTION  30()
Called 25 times
Total time:   0.006601
 Self time:   0.000951

count  total (s)   self (s)
   25              0.000497     let newPath = copy(self)
                            
   25   0.005677   0.000211     call newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:path))
                            
   25              0.000047     let newPath.cachedDisplayString = ""
   25   0.000299   0.000115     let newPath.flagSet = g:NERDTreeFlagSet.New()
                            
   25              0.000025     return newPath

FUNCTION  31()
Called 8 times
Total time:   0.000133
 Self time:   0.000055

count  total (s)   self (s)
    8   0.000129   0.000051     return nerdtree#runningWindows() ? '\' : '/'

FUNCTION  32()
Called 51 times
Total time:   0.000929
 Self time:   0.000929

count  total (s)   self (s)
   51              0.000386     let tmp = resolve(a:path)
   51              0.000513     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp

FUNCTION  33()
Called 25 times
Total time:   0.004679
 Self time:   0.002447

count  total (s)   self (s)
   25   0.000697   0.000096     call self.extractDriveLetter(a:fullpath)
                            
   25   0.000378   0.000118     let fullpath = s:Path.WinToUnixPath(a:fullpath)
                            
   25              0.000208     if getftype(fullpath) ==# "fifo"
                                    throw "NERDTree.InvalidFiletypeError: Cant handle FIFO files: " . a:fullpath
                                endif
                            
   25              0.000190     let self.pathSegments = split(fullpath, '/')
                            
   25              0.000052     let self.isReadOnly = 0
   25              0.000111     if isdirectory(a:fullpath)
    8              0.000016         let self.isDirectory = 1
    8              0.000013     elseif filereadable(a:fullpath)
   17              0.000038         let self.isDirectory = 0
   17              0.000132         let self.isReadOnly = filewritable(a:fullpath) ==# 0
   17              0.000014     else
                                    throw "NERDTree.InvalidArgumentsError: Invalid path = " . a:fullpath
                                endif
                            
   25              0.000052     let self.isExecutable = 0
   25              0.000029     if !self.isDirectory
   17              0.000113         let self.isExecutable = getfperm(a:fullpath) =~# 'x'
   17              0.000014     endif
                            
                                "grab the last part of the path (minus the trailing slash)
   25   0.000389   0.000122     let lastPathComponent = self.getLastPathComponent(0)
                            
                                "get the path to the new node with the parent dir fully resolved
   25   0.000842   0.000185     let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent
                            
                                "if  the last part of the path is a symlink then flag it as such
   25   0.000628   0.000181     let self.isSymLink = (s:Path.Resolve(hardPath) != hardPath)
   25              0.000030     if self.isSymLink
                                    let self.symLinkDest = s:Path.Resolve(fullpath)
                            
                                    "if the link is a dir then slap a / on the end of its dest
                                    if isdirectory(self.symLinkDest)
                            
                                        "we always wanna treat MS windows shortcuts as files for
                                        "simplicity
                                        if hardPath !~# '\.lnk$'
                            
                                            let self.symLinkDest = self.symLinkDest . '/'
                                        endif
                                    endif
                                endif

FUNCTION  37()
Called 5 times
Total time:   0.001212
 Self time:   0.000845

count  total (s)   self (s)
    5              0.000016     let options = a:0 ? a:1 : {}
    5              0.000010     let toReturn = ""
                            
    5              0.000016     if has_key(options, 'format')
    2              0.000004         let format = options['format']
    2              0.000005         if has_key(self, '_strFor' . format)
    2   0.000115   0.000022             exec 'let toReturn = self._strFor' . format . '()'
    2              0.000002         else
                                        throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
                                    endif
    2              0.000001     else
    3   0.000283   0.000032         let toReturn = self._str()
    3              0.000005     endif
                            
    5   0.000057   0.000033     if nerdtree#has_opt(options, 'escape')
                                    let toReturn = shellescape(toReturn)
                                endif
                            
    5              0.000012     if has_key(options, 'truncateTo')
    1              0.000003         let limit = options['truncateTo']
    1              0.000003         if len(toReturn) > limit-1
                                        let toReturn = toReturn[(len(toReturn)-limit+1):]
                                        if len(split(toReturn, '/')) > 1
                                            let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
                                        else
                                            let toReturn = '<' . toReturn
                                        endif
                                    endif
    1              0.000008     endif
                            
    5              0.000029     return toReturn

FUNCTION  38()
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000006     let toReturn = '/' . join(self.pathSegments, '/')
    1              0.000003     if self.isDirectory && toReturn != '/'
    1              0.000002         let toReturn  = toReturn . '/'
    1              0.000001     endif
    1              0.000001     return toReturn

FUNCTION  122()
Called 1 time
Total time:   0.000503
 Self time:   0.000050

count  total (s)   self (s)
    1   0.000466   0.000012     let ln = self.getNerdtree().ui.getLineNum(self)
    1              0.000002     if ln != -1
    1              0.000002         if a:isJump
                                        mark '
                                    endif
    1              0.000006         call cursor(ln, col("."))
    1              0.000001     else
                                    if a:recurseUpward
                                        let node = self
                                        while node != {} && self.getNerdtree().ui.getLineNum(node) ==# -1
                                            let node = node.parent
                                            call node.open()
                                        endwhile
                                        call self._nerdtree.render()
                                        call node.putCursorHere(a:isJump, 0)
                                    endif
                                endif

FUNCTION  126()
Called 1 time
Total time:   0.007975
 Self time:   0.000034

count  total (s)   self (s)
    1   0.007974   0.000032     return self._renderToString(0, 0)

FUNCTION  127()
Called 25 times
Total time:   0.011395
 Self time:   0.009258

count  total (s)   self (s)
   25              0.000044     let output = ""
   25              0.000028     if a:drawText ==# 1
                            
   24              0.000056         let treeParts = repeat('  ', a:depth - 1)
                            
   24              0.000036         if !self.path.isDirectory
   17              0.000027             let treeParts = treeParts . '  '
   17              0.000011         endif
                            
   24   0.002083   0.000108         let line = treeParts . self.displayString()
                            
   24              0.000054         let output = output . line . "\n"
   24              0.000015     endif
                            
                                "if the node is an open dir, draw its children
   25              0.000039     if self.path.isDirectory ==# 1 && self.isOpen ==# 1
                            
    1   0.002101   0.000011         let childNodesToDraw = self.getVisibleChildren()
                            
    1   0.002025   0.000012         if self.isCascadable() && a:depth > 0
                            
                                        let output = output . childNodesToDraw[0]._renderToString(a:depth, 0)
                            
                                    elseif len(childNodesToDraw) > 0
   25              0.000028             for i in childNodesToDraw
   24              0.000089                 let output = output . i._renderToString(a:depth + 1, 1)
   24              0.000024             endfor
    1              0.000001         endif
    1              0.000001     endif
                            
   25              0.000027     return output

FUNCTION  gutentags#normalizepath()
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000003     if exists('+shellslash') && &shellslash
                                    return substitute(a:path, '\v/', '\\', 'g')
                                elseif has('win32')
                                    return substitute(a:path, '\v/', '\\', 'g')
                                else
    1              0.000001         return a:path
                                endif

FUNCTION  41()
Called 1 time
Total time:   0.000079
 Self time:   0.000033

count  total (s)   self (s)
    1   0.000017   0.000005     let lead = s:Path.Slash()
                            
                                "if we are running windows then slap a drive letter on the front
    1   0.000008   0.000002     if nerdtree#runningWindows()
                                    let lead = self.drive . '\'
                                endif
                            
    1   0.000018   0.000007     let toReturn = lead . join(self.pathSegments, s:Path.Slash())
                            
    1   0.000008   0.000003     if !nerdtree#runningWindows()
    1   0.000021   0.000009         let toReturn = escape(toReturn, self._escChars())
    1              0.000001     endif
    1              0.000001     return toReturn

FUNCTION  42()
Called 3 times
Total time:   0.000251
 Self time:   0.000113

count  total (s)   self (s)
    3   0.000096   0.000038     let lead = s:Path.Slash()
                            
                                "if we are running windows then slap a drive letter on the front
    3   0.000046   0.000017     if nerdtree#runningWindows()
                                    let lead = self.drive . '\'
                                endif
                            
    3   0.000090   0.000038     return lead . join(self.pathSegments, s:Path.Slash())

FUNCTION  43()
Called 25 times
Total time:   0.000202
 Self time:   0.000202

count  total (s)   self (s)
   25              0.000193     return self.drive . '/' . join(self.pathSegments[0:-2], '/')

FUNCTION  45()
Called 25 times
Total time:   0.000260
 Self time:   0.000111

count  total (s)   self (s)
   25   0.000216   0.000067     if !nerdtree#runningWindows()
   25              0.000029         return a:pathstr
                                endif
                            
                                let toReturn = a:pathstr
                            
                                "remove the x:\ of the front
                                let toReturn = substitute(toReturn, '^.*:\(\\\|/\)\?', '/', "")
                            
                                "remove the \\ network share from the front
                                let toReturn = substitute(toReturn, '^\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\(\\\|\/\)\?', '/', "")
                            
                                "convert all \ chars to /
                                let toReturn = substitute(toReturn, '\', '/', "g")
                            
                                return toReturn

FUNCTION  <SNR>89_should_change_group()
Called 28 times
Total time:   0.006255
 Self time:   0.000737

count  total (s)   self (s)
   28              0.000060   if a:group1 == a:group2
                                return 0
                              endif
   28   0.003030   0.000180   let color1 = airline#highlighter#get_highlight(a:group1)
   28   0.002841   0.000173   let color2 = airline#highlighter#get_highlight(a:group2)
   28              0.000051   if g:airline_gui_mode ==# 'gui'
                                return color1[1] != color2[1] || color1[0] != color2[0]
                              else
   28              0.000091     return color1[3] != color2[3] || color1[2] != color2[2]
                              endif

FUNCTION  <SNR>79_get_hunks()
Called 280 times
Total time:   1.823208
 Self time:   0.009568

count  total (s)   self (s)
  280              0.001812   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
                                if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
                                  let b:source_func = 's:get_hunks_gitgutter'
                                elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                else
                                  let b:source_func = 's:get_hunks_empty'
                                endif
                              endif
  280   1.816060   0.002419   return {b:source_func}()

FUNCTION  <SNR>40_buffer_getvar()
Called 10 times
Total time:   0.000064
 Self time:   0.000064

count  total (s)   self (s)
   10              0.000058   return getbufvar(self['#'],a:var)

FUNCTION  130()
Called 24 times
Total time:   0.000222
 Self time:   0.000222

count  total (s)   self (s)
   24              0.000071     call add(self.children, a:treenode)
   24              0.000042     let a:treenode.parent = self
                            
   24              0.000023     if a:inOrder
                                    call self.sortChildren()
                                endif

FUNCTION  133()
Called 24 times
Total time:   0.001557
 Self time:   0.000318

count  total (s)   self (s)
   24   0.001189   0.000172     let newTreeNode = g:NERDTreeFileNode.New(a:path, self.getNerdtree())
   24   0.000324   0.000103     call self.addChild(newTreeNode, a:inOrder)
   24              0.000026     return newTreeNode

FUNCTION  134()
Called 7 times
Total time:   0.000855
 Self time:   0.000195

count  total (s)   self (s)
    7   0.000226   0.000026     let cascade = self.getCascade()
    7              0.000009     let rv = ""
   14              0.000018     for node in cascade
    7   0.000419   0.000030         let rv = rv . node.path.displayString()
    7              0.000005     endfor
                            
    7              0.000021     let sym = cascade[-1].isOpen ? g:NERDTreeDirArrowCollapsible : g:NERDTreeDirArrowExpandable
                            
    7   0.000100   0.000029     let flags = cascade[-1].path.flagSet.renderToString()
                            
    7              0.000018     return sym . ' ' . flags . rv

FUNCTION  136()
Called 7 times
Total time:   0.000200
 Self time:   0.000039

count  total (s)   self (s)
    7   0.000187   0.000026     if !self.isCascadable()
    7              0.000009         return [self]
                                endif
                            
                                let vc = self.getVisibleChildren()
                                let visChild = vc[0]
                            
                                return [self] + visChild.getCascade()

FUNCTION  137()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002     return len(self.children)

FUNCTION  airline#highlighter#get_highlight()
Called 1028 times
Total time:   0.113111
 Self time:   0.035368

count  total (s)   self (s)
 1028   0.041770   0.005922   let fg = s:get_syn(a:group, 'fg')
 1028   0.039430   0.005842   let bg = s:get_syn(a:group, 'bg')
 1028              0.014770   let reverse = g:airline_gui_mode ==# 'gui' ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
 1028   0.015977   0.007670   return reverse ? s:get_array(bg, fg, a:000) : s:get_array(fg, bg, a:000)

FUNCTION  gitgutter#diff#is_modified()
Called 12 times
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
   12              0.000041   return a:from_count > 0 && a:to_count > 0 && a:from_count == a:to_count

FUNCTION  gitgutter#utility#has_fresh_changes()
Called 10 times
Total time:   0.000240
 Self time:   0.000085

count  total (s)   self (s)
   10   0.000234   0.000079   return getbufvar(s:bufnr, 'changedtick') != gitgutter#utility#getbufvar(s:bufnr, 'last_tick')

FUNCTION  <SNR>40_can_diffoff()
Called 4 times
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    4              0.000035   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getbufvar(a:buf, 'git_dir')) && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))

FUNCTION  144()
Called 9 times
Total time:   0.004172
 Self time:   0.000545

count  total (s)   self (s)
    9              0.000014     let toReturn = []
   57              0.000063     for i in self.children
   48   0.003860   0.000232         if i.path.ignore(self.getNerdtree()) ==# 0
   48              0.000088             call add(toReturn, i)
   48              0.000030         endif
   48              0.000031     endfor
    9              0.000009     return toReturn

FUNCTION  146()
Called 8 times
Total time:   0.002174
 Self time:   0.000091

count  total (s)   self (s)
    8              0.000016     if g:NERDTreeCascadeSingleChildDir == 0
                                    return 0
                                endif
                            
    8   0.002118   0.000035     let c = self.getVisibleChildren()
    8              0.000017     return len(c) == 1 && c[0].path.isDirectory

FUNCTION  147()
Called 1 time
Total time:   0.020691
 Self time:   0.001446

count  total (s)   self (s)
                                "remove all the current child nodes
    1              0.000002     let self.children = []
                            
                                "get an array of all the files in the nodes dir
    1              0.000001     let dir = self.path
    1   0.000150   0.000010     let globDir = dir.str({'format': 'Glob'})
                            
    1              0.000001     if version >= 703
    1              0.000312         let filesStr = globpath(globDir, '*', !g:NERDTreeRespectWildIgnore) . "\n" . globpath(globDir, '.*', !g:NERDTreeRespectWildIgnore)
    1              0.000001     else
                                    let filesStr = globpath(globDir, '*') . "\n" . globpath(globDir, '.*')
                                endif
                            
    1              0.000045     let files = split(filesStr, "\n")
                            
    1              0.000007     if !a:silent && len(files) > g:NERDTreeNotificationThreshold
                                    call nerdtree#echo("Please wait, caching a large dir ...")
                                endif
                            
    1              0.000003     let invalidFilesFound = 0
   27              0.000040     for i in files
                            
                                    "filter out the .. and . directories
                                    "Note: we must match .. AND ../ since sometimes the globpath returns
                                    "../ for path with strange chars (eg $)
   26              0.000199         if i[len(i)-3:2] != ".." && i[len(i)-2:2] != ".." && i[len(i)-2:1] != "." && i[len(i)-1] != "."
                                        "put the next file in a new node and attach it
   24              0.000024             try
   24   0.006422   0.000111                 let path = g:NERDTreePath.New(i)
   24   0.001770   0.000213                 call self.createChild(path, 0)
   24   0.001241   0.000199                 call g:NERDTreePathNotifier.NotifyListeners('init', path, self.getNerdtree(), {})
   24              0.000033             catch /^NERDTree.\(InvalidArguments\|InvalidFiletype\)Error/
                                            let invalidFilesFound += 1
                                        endtry
   24              0.000017         endif
   26              0.000018     endfor
                            
    1   0.010205   0.000013     call self.sortChildren()
                            
    1              0.000004     if !a:silent && len(files) > g:NERDTreeNotificationThreshold
                                    call nerdtree#echo("Please wait, caching a large dir ... DONE (". self.getChildCount() ." nodes cached).")
                                endif
                            
    1              0.000001     if invalidFilesFound
                                    call nerdtree#echoWarning(invalidFilesFound . " file(s) could not be loaded into the NERD tree")
                                endif
    1   0.000014   0.000012     return self.getChildCount()

FUNCTION  148()
Called 8 times
Total time:   0.000398
 Self time:   0.000398

count  total (s)   self (s)
    8              0.000014     if a:path.isDirectory != 1
                                    throw "NERDTree.InvalidArgumentsError: A TreeDirNode object must be instantiated with a directory Path object."
                                endif
                            
    8              0.000253     let newTreeNode = copy(self)
    8              0.000018     let newTreeNode.path = a:path
                            
    8              0.000015     let newTreeNode.isOpen = 0
    8              0.000014     let newTreeNode.children = []
                            
    8              0.000013     let newTreeNode.parent = {}
    8              0.000014     let newTreeNode._nerdtree = a:nerdtree
                            
    8              0.000009     return newTreeNode

FUNCTION  149()
Called 1 time
Total time:   0.020724
 Self time:   0.000032

count  total (s)   self (s)
    1              0.000002     let opts = a:0 ? a:1 : {}
                            
    1              0.000003     if has_key(opts, 'where') && !empty(opts['where'])
                                    let opener = g:NERDTreeOpener.New(self.path, opts)
                                    call opener.open(self)
                                else
    1              0.000001         let self.isOpen = 1
    1              0.000002         if self.children ==# []
    1   0.020709   0.000018             return self._initChildren(0)
                                    else
                                        return 0
                                    endif
                                endif

FUNCTION  gitgutter#sign#add_dummy_sign()
Called 21 times
Total time:   0.000994
 Self time:   0.000501

count  total (s)   self (s)
   21   0.000188   0.000134   let bufnr = gitgutter#utility#bufnr()
   21   0.000577   0.000138   if !gitgutter#utility#getbufvar(bufnr, 'dummy_sign')
                                execute "sign place" s:dummy_sign_id "line=" . 9999 "name=GitGutterDummy buffer=" . bufnr
                                call gitgutter#utility#setbufvar(bufnr, 'dummy_sign', 1)
                              endif

FUNCTION  ale#engine#InitBufferInfo()
Called 15 times
Total time:   0.000214
 Self time:   0.000214

count  total (s)   self (s)
   15              0.000062     if !has_key(g:ale_buffer_info, a:buffer)
                                    " job_list will hold the list of jobs
                                    " loclist holds the loclist items after all jobs have completed.
                                    " lint_file_loclist holds items from the last run including linters
                                    "   which use the lint_file option.
                                    " new_loclist holds loclist items while jobs are being run.
                                    " temporary_file_list holds temporary files to be cleaned up
                                    " temporary_directory_list holds temporary directories to be cleaned up
                                    " history holds a list of previously run commands for this buffer
                                    let g:ale_buffer_info[a:buffer] = {   'job_list': [],   'loclist': [],   'lint_file_loclist': [],   'new_loclist': [],   'temporary_file_list': [],   'temporary_directory_list': [],   'history': [],}
                                endif

FUNCTION  <SNR>85_Get()
Called 3591 times
Total time:   0.027046
 Self time:   0.027046

count  total (s)   self (s)
 3591              0.012469   if get(a:dict, a:key, a:default) isnot# a:default
 2322              0.007335     return a:prefix. get(a:dict, a:key)
                              else
 1269              0.001278     return ''
                              endif

FUNCTION  67()
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000005     if !exists("s:keyMaps")
                                    let s:keyMaps = []
                                endif
    1              0.000001     return s:keyMaps

FUNCTION  69()
Called 1 time
Total time:   0.002131
 Self time:   0.000363

count  total (s)   self (s)
   51   0.000100   0.000092     for i in s:KeyMap.All()
   50   0.001971   0.000212         call i.bind()
   50              0.000046     endfor

FUNCTION  airline#util#append()
Called 1680 times
Total time:   0.020657
 Self time:   0.020657

count  total (s)   self (s)
 1680              0.004144   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
 1680              0.006277   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
 1680              0.005443   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  airline#section#create()
Called 2 times
Total time:   0.000734
 Self time:   0.000022

count  total (s)   self (s)
    2   0.000733   0.000021   return s:create(a:parts, 0)

FUNCTION  airline#extensions#default#apply()
Called 8 times
Total time:   0.004040
 Self time:   0.000401

count  total (s)   self (s)
    8              0.000018   let winnr = a:context.winnr
    8              0.000014   let active = a:context.active
                            
    8   0.000078   0.000048   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
    5   0.001317   0.000040     call s:build_sections(a:builder, a:context, s:layout[0])
    5              0.000004   else
    3   0.000123   0.000015     let text = s:get_section(winnr, 'c')
    3              0.000005     if empty(text)
                                  let text = ' %f%m '
                                endif
    3   0.000031   0.000019     call a:builder.add_section('airline_c'.(a:context.bufnr), text)
    3              0.000002   endif
                            
    8   0.000362   0.000064   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
    8   0.000048   0.000028   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
    7   0.001930   0.000035     call s:build_sections(a:builder, a:context, s:layout[1])
    7              0.000006   endif
                            
    8              0.000007   return 1

FUNCTION  gutentags#setup_gutentags()
Called 1 time
Total time:   0.000677
 Self time:   0.000412

count  total (s)   self (s)
    1              0.000004     if exists('b:gutentags_files') && !g:gutentags_debug
                                    " This buffer already has gutentags support.
                                    return
                                endif
                            
                                " Don't setup gutentags for anything that's not a normal buffer
                                " (so don't do anything for help buffers and quickfix windows and
                                "  other such things)
                                " Also don't do anything for the default `[No Name]` buffer you get
                                " after starting Vim.
    1              0.000005     if &buftype != '' || bufname('%') == ''
                                    return
                                endif
                            
                                " Let the user specify custom ways to disable Gutentags.
    1              0.000004     if g:gutentags_init_user_func != '' &&!call(g:gutentags_init_user_func, [expand('%:p')])
                                    call gutentags#trace("Ignoring '" . bufname('%') . "' because of " ."custom user function.")
                                    return
                                endif
                            
                                " Try and find what tags file we should manage.
    1   0.000015   0.000008     call gutentags#trace("Scanning buffer '" . bufname('%') . "' for gutentags setup...")
    1              0.000001     try
    1              0.000024         let l:buf_dir = expand('%:p:h', 1)
    1              0.000002         if g:gutentags_resolve_symlinks
                                        let l:buf_dir = fnamemodify(resolve(expand('%:p', 1)), ':p:h')
                                    endif
    1              0.000002         if !exists('b:gutentags_root')
    1   0.000131   0.000016             let b:gutentags_root = gutentags#get_project_root(l:buf_dir)
    1              0.000001         endif
    1              0.000007         if filereadable(b:gutentags_root . '/.notags')
                                        call gutentags#trace("'.notags' file found... no gutentags support.")
                                        return
                                    endif
                            
    1              0.000003         if !has_key(s:known_projects, b:gutentags_root)
                                        call s:cache_project_root(b:gutentags_root)
                                    endif
    1              0.000001         if g:gutentags_trace
                                        let l:projnfo = gutentags#get_project_info(b:gutentags_root)
                                        if l:projnfo != {}
                                            call gutentags#trace("Setting project type to ".l:projnfo['type'])
                                        else
                                            call gutentags#trace("No specific project type.")
                                        endif
                                    endif
                            
    1              0.000002         let b:gutentags_files = {}
    2              0.000003         for module in g:gutentags_modules
    1   0.000150   0.000011             call call("gutentags#".module."#init", [b:gutentags_root])
    1              0.000001         endfor
    1              0.000001     catch /^gutentags\:/
                                    call gutentags#trace("No gutentags support for this buffer.")
                                    return
                                endtry
                            
                                " We know what tags file to manage! Now set things up.
    1   0.000012   0.000006     call gutentags#trace("Setting gutentags for buffer '".bufname('%')."'")
                            
                                " Autocommands for updating the tags on save.
                                " We need to pass the buffer number to the callback function in the rare
                                " case that the current buffer is changed by another `BufWritePost`
                                " callback. This will let us get that buffer's variables without causing
                                " errors.
    1              0.000002     let l:bn = bufnr('%')
    1              0.000007     execute 'augroup gutentags_buffer_' . l:bn
    1              0.000183     execute '  autocmd!'
    1              0.000011     execute '  autocmd BufWritePost <buffer=' . l:bn . '> call s:write_triggered_update_tags(' . l:bn . ')'
    1              0.000002     execute 'augroup end'
                            
                                " Miscellaneous commands.
    1              0.000006     command! -buffer -bang GutentagsUpdate :call s:manual_update_tags(<bang>0)
                            
                                " Add these tags files to the known tags files.
    2              0.000005     for module in keys(b:gutentags_files)
    1              0.000003         let l:tagfile = b:gutentags_files[module]
    1              0.000003         let l:found = index(s:known_files, l:tagfile)
    1              0.000001         if l:found < 0
                                        call add(s:known_files, l:tagfile)
                            
                                        " Generate this new file depending on settings and stuff.
                                        if g:gutentags_enabled
                                            if g:gutentags_generate_on_missing && !filereadable(l:tagfile)
                                                call gutentags#trace("Generating missing tags file: " . l:tagfile)
                                                call s:update_tags(l:bn, module, 1, 1)
                                            elseif g:gutentags_generate_on_new
                                                call gutentags#trace("Generating tags file: " . l:tagfile)
                                                call s:update_tags(l:bn, module, 1, 1)
                                            endif
                                        endif
                                    endif
    1              0.000001     endfor

FUNCTION  <SNR>40_cpath()
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000005   if exists('+fileignorecase') && &fileignorecase
                                return tolower(a:path)
                              else
    1              0.000002     return a:path
                              endif

FUNCTION  70()
Called 50 times
Total time:   0.001759
 Self time:   0.001759

count  total (s)   self (s)
                                " If the key sequence we're trying to map contains any '<>' notation, we
                                " must replace each of the '<' characters with '<lt>' to ensure the string
                                " is not translated into its corresponding keycode during the later part
                                " of the map command below
                                " :he <>
   50              0.000113     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
   50              0.000253     if self.key =~# specialNotationRegex
    8              0.000069         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
    8              0.000006     else
   42              0.000078         let keymapInvokeString = self.key
   42              0.000034     endif
                            
   50              0.000116     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
                            
   50              0.000750     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'

FUNCTION  78()
Called 25 times
Total time:   0.000149
 Self time:   0.000149

count  total (s)   self (s)
   25              0.000057     if !exists("g:NERDTreeBookmarks")
    1              0.000007         let g:NERDTreeBookmarks = []
    1              0.000001     endif
   25              0.000028     return g:NERDTreeBookmarks

FUNCTION  79()
Called 1 time
Total time:   0.000543
 Self time:   0.000069

count  total (s)   self (s)
    1              0.000002     try
    1   0.000489   0.000015         call s:Bookmark.BookmarkFor(a:name)
                                    return 1
                                catch /^NERDTree.BookmarkNotFoundError/
    1              0.000005         return 0
                                endtry

FUNCTION  161()
Called 1 time
Total time:   0.010192
 Self time:   0.001017

count  total (s)   self (s)
    1              0.000007     let CompareFunc = function("nerdtree#compareNodesBySortKey")
    1   0.010185   0.001010     call sort(self.children, CompareFunc)

FUNCTION  airline#highlighter#add_separator()
Called 35 times
Total time:   0.018842
 Self time:   0.000810

count  total (s)   self (s)
   35              0.000299   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
   35   0.018517   0.000485   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  <SNR>85_get_syn()
Called 2056 times
Total time:   0.069435
 Self time:   0.069435

count  total (s)   self (s)
 2056              0.006908   if !exists("g:airline_gui_mode")
                                let g:airline_gui_mode = airline#init#gui_mode()
                              endif
 2056              0.003156   let color = ''
 2056              0.006286   if hlexists(a:group)
 1986              0.012482     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, g:airline_gui_mode)
 1986              0.002321   endif
 2056              0.005352   if empty(color) || color == -1
                                " should always exists
   83              0.001031     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, g:airline_gui_mode)
                                " however, just in case
   83              0.000149     if empty(color) || color == -1
   83              0.000107       let color = 'NONE'
   83              0.000055     endif
   83              0.000047   endif
 2056              0.002673   return color

FUNCTION  80()
Called 1 time
Total time:   0.000474
 Self time:   0.000456

count  total (s)   self (s)
    1   0.000445   0.000427     for i in s:Bookmark.Bookmarks()
                                    if i.name ==# a:name
                                        return i
                                    endif
                                endfor
                                throw "NERDTree.BookmarkNotFoundError: no bookmark found for name: \"". a:name  .'"'

FUNCTION  gitgutter#utility#set_buffer()
Called 71 times
Total time:   0.001750
 Self time:   0.001750

count  total (s)   self (s)
   71              0.000229   let s:bufnr = a:bufnr
   71              0.001418   let s:file = resolve(bufname(a:bufnr))

FUNCTION  <SNR>7_SynSet()
Called 1 time
Total time:   0.002631
 Self time:   0.002147

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    1              0.000005   syn clear
    1              0.000004   if exists("b:current_syntax")
                                unlet b:current_syntax
                              endif
                            
    1              0.000004   let s = expand("<amatch>")
    1              0.000002   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
                              elseif s == "OFF"
                                let s = ""
                              endif
                            
    1              0.000001   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
    2              0.000012     for name in split(s, '\.')
    1   0.002575   0.002091       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    1              0.000004     endfor
    1              0.000001   endif

FUNCTION  gitgutter#debug#log()
Called 49 times
Total time:   0.002956
 Self time:   0.002956

count  total (s)   self (s)
   49              0.000242   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
                              endif

FUNCTION  179()
Called 1 time
Total time:   0.002197
 Self time:   0.000066

count  total (s)   self (s)
                                "make <cr> do the same as the activate node mapping
    1              0.000015     nnoremap <silent> <buffer> <cr> :call nerdtree#ui_glue#invokeKeyMap(g:NERDTreeMapActivateNode)<cr>
                            
    1   0.002140   0.000009     call g:NERDTreeKeyMap.BindAll()
                            
    1              0.000006     command! -buffer -nargs=? Bookmark :call nerdtree#ui_glue#bookmarkNode('<args>')
    1              0.000006     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 RevealBookmark :call nerdtree#ui_glue#revealBookmark('<args>')
    1              0.000004     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 OpenBookmark :call nerdtree#ui_glue#openBookmark('<args>')
    1              0.000004     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=* ClearBookmarks call nerdtree#ui_glue#clearBookmarks('<args>')
    1              0.000005     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=+ BookmarkToRoot call g:NERDTreeBookmark.ToRoot('<args>', b:NERDTree)
    1              0.000005     command! -buffer -nargs=0 ClearAllBookmarks call g:NERDTreeBookmark.ClearAll() <bar> call b:NERDTree.render()
    1              0.000005     command! -buffer -nargs=0 ReadBookmarks call g:NERDTreeBookmark.CacheBookmarks(0) <bar> call b:NERDTree.render()
    1              0.000003     command! -buffer -nargs=0 WriteBookmarks call g:NERDTreeBookmark.Write()

FUNCTION  <SNR>89_get_transitioned_seperator()
Called 35 times
Total time:   0.019738
 Self time:   0.000896

count  total (s)   self (s)
   35              0.000061   let line = ''
   35   0.019118   0.000277   call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
   35              0.000196   let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
   35              0.000153   let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
   35              0.000111   let line .= '%#'.a:group.'#'
   35              0.000048   return line

FUNCTION  <SNR>80_update_untracked_in_buffer_config()
Called 1124 times
Total time:   0.018536
 Self time:   0.018536

count  total (s)   self (s)
 1124              0.004372   if !has_key(s:vcs_config[a:vcs].untracked, a:file)
                                return
                              elseif s:vcs_config[a:vcs].untracked[a:file] != b:buffer_vcs_config[a:vcs].untracked
                                let b:buffer_vcs_config[a:vcs].untracked = s:vcs_config[a:vcs].untracked[a:file]
                                unlet! b:airline_head
                              endif

FUNCTION  gutentags#ctags#init()
Called 1 time
Total time:   0.000139
 Self time:   0.000079

count  total (s)   self (s)
                                " Figure out the path to the tags file.
                                " Check the old name for this option, too, before falling back to the
                                " globally defined name.
    1              0.000006     let l:tagfile = getbufvar("", 'gutentags_ctags_tagfile',getbufvar("", 'gutentags_tagfile', g:gutentags_ctags_tagfile))
    1   0.000071   0.000011     let b:gutentags_files['ctags'] = gutentags#get_cachefile(a:project_root, l:tagfile)
                            
                                " Set the tags file for Vim to use.
    1              0.000001     if g:gutentags_ctags_auto_set_tags
    1              0.000016         execute 'setlocal tags^=' . fnameescape(b:gutentags_files['ctags'])
    1              0.000001     endif
                            
                                " Check if the ctags executable exists.
    1              0.000036     if g:gutentags_enabled && executable(expand(g:gutentags_ctags_executable, 1)) == 0
                                    let g:gutentags_enabled = 0
                                    echoerr "Executable '".g:gutentags_ctags_executable."' can't be found. "."Gutentags will be disabled. You can re-enable it by "."setting g:gutentags_enabled back to 1."
                                endif

FUNCTION  <SNR>80_check_in_path()
Called 6 times
Total time:   0.000199
 Self time:   0.000199

count  total (s)   self (s)
    6              0.000019   if !exists('b:airline_file_in_root')
                                let root = get(b:, 'git_dir', get(b:, 'mercurial_dir', ''))
                                let bufferpath = resolve(fnamemodify(expand('%'), ':p'))
                            
                                if !filereadable(root) "not a file
                                  " if .git is a directory, it's the old submodule format
                                  if match(root, '\.git$') >= 0
                                    let root = expand(fnamemodify(root, ':h'))
                                  else
                                    " else it's the newer format, and we need to guesstimate
                                    " 1) check for worktrees
                                    if match(root, 'worktrees') > -1
                                      " worktree can be anywhere, so simply assume true here
                                      return 1
                                    endif
                                    " 2) check for submodules
                                    let pattern = '\.git[\\/]\(modules\)[\\/]'
                                    if match(root, pattern) >= 0
                                      let root = substitute(root, pattern, '', '')
                                    endif
                                  endif
                                endif
                            
                                let b:airline_file_in_root = stridx(bufferpath, root) > -1
                              endif
    6              0.000009   return b:airline_file_in_root

FUNCTION  180()
Called 1 time
Total time:   0.001922
 Self time:   0.000068

count  total (s)   self (s)
    1   0.001921   0.000067     silent doautocmd User NERDTreeInit

FUNCTION  181()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000001     return 'NERD_tree_'

FUNCTION  183()
Called 1 time
Total time:   0.092499
 Self time:   0.000085

count  total (s)   self (s)
    1   0.000952   0.000011     let path = self._pathForString(a:name)
                            
                                "abort if exception was thrown (bookmark/dir doesn't exist)
    1              0.000001     if empty(path)
                                    return
                                endif
                            
    1              0.000002     if path == {}
                                    return
                                endif
                            
                                "if instructed to, then change the vim CWD to the dir the NERDTree is
                                "inited in
    1              0.000002     if g:NERDTreeChDirMode != 0
                                    call path.changeToDir()
                                endif
                            
    1   0.000008   0.000004     if g:NERDTree.ExistsForTab()
                                    if g:NERDTree.IsOpen()
                                        call g:NERDTree.Close()
                                    endif
                            
                                    call self._removeTreeBufForTab()
                                endif
                            
    1   0.059129   0.000007     call self._createTreeWin()
    1   0.020879   0.000011     call self._createNERDTree(path, "tab")
    1   0.009062   0.000008     call b:NERDTree.render()
    1   0.000514   0.000011     call b:NERDTree.root.putCursorHere(0, 0)
                            
    1   0.001933   0.000012     call self._broadcastInitEvent()

FUNCTION  186()
Called 1 time
Total time:   0.020868
 Self time:   0.000028

count  total (s)   self (s)
    1   0.000133   0.000017     let b:NERDTree = g:NERDTree.New(a:path, a:type)
                                "TODO: This is kept for compatability only since many things use
                                "b:NERDTreeRoot instead of the new NERDTree.root
                                "Remove this one day
    1              0.000002     let b:NERDTreeRoot = b:NERDTree.root
                            
    1   0.020730   0.000007     call b:NERDTree.root.open()

FUNCTION  189()
Called 1 time
Total time:   0.059121
 Self time:   0.006929

count  total (s)   self (s)
                                "create the nerd tree window
    1              0.000003     let splitLocation = g:NERDTreeWinPos ==# "left" ? "topleft " : "botright "
    1              0.000002     let splitSize = g:NERDTreeWinSize
                            
    1              0.000002     if !exists('t:NERDTreeBufName')
    1   0.000032   0.000006         let t:NERDTreeBufName = self._nextBufferName()
    1   0.016484   0.000197         silent! exec splitLocation . 'vertical ' . splitSize . ' new'
    1   0.014707   0.006686         silent! exec "edit " . t:NERDTreeBufName
    1              0.000002     else
                                    silent! exec splitLocation . 'vertical ' . splitSize . ' split'
                                    silent! exec "buffer " . t:NERDTreeBufName
                                endif
                            
    1              0.000008     setlocal winfixwidth
    1   0.027869   0.000011     call self._setCommonBufOptions()

FUNCTION  <SNR>40_sub()
Called 566 times
Total time:   0.011354
 Self time:   0.011354

count  total (s)   self (s)
  566              0.010959   return substitute(a:str,'\v\C'.a:pat,a:rep,'')

FUNCTION  airline#util#getwinvar()
Called 62 times
Total time:   0.000209
 Self time:   0.000209

count  total (s)   self (s)
   62              0.000183     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  gutentags#get_cachefile()
Called 1 time
Total time:   0.000060
 Self time:   0.000033

count  total (s)   self (s)
    1   0.000012   0.000008     if gutentags#is_path_rooted(a:filename)
                                    return a:filename
                                endif
    1   0.000016   0.000005     let l:tag_path = gutentags#stripslash(a:root_dir) . '/' . a:filename
    1              0.000002     if g:gutentags_cache_dir != ""
                                    " Put the tag file in the cache dir instead of inside the
                                    " project root.
                                    let l:tag_path = g:gutentags_cache_dir . '/' .tr(l:tag_path, '\/: ', '---_')
                                    let l:tag_path = substitute(l:tag_path, '/\-', '/', '')
                                endif
    1   0.000020   0.000008     let l:tag_path = gutentags#normalizepath(l:tag_path)
    1              0.000001     return l:tag_path

FUNCTION  <SNR>89_get_prev_group()
Called 51 times
Total time:   0.000649
 Self time:   0.000649

count  total (s)   self (s)
   51              0.000095   let x = a:i - 1
   58              0.000081   while x >= 0
   50              0.000114     let group = a:sections[x][0]
   50              0.000118     if group != '' && group != '|'
   43              0.000057       return group
                                endif
    7              0.000009     let x = x - 1
    7              0.000006   endwhile
    8              0.000008   return ''

FUNCTION  <SNR>52_Highlight_Matching_Pair()
Called 232 times
Total time:   0.025502
 Self time:   0.025502

count  total (s)   self (s)
                              " Remove any previous match.
  232              0.001088   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
                              endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  232              0.001148   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  232              0.000806   let c_lnum = line('.')
  232              0.000701   let c_col = col('.')
  232              0.000589   let before = 0
                            
  232              0.000823   let text = getline(c_lnum)
  232              0.004423   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
  232              0.000744   if empty(matches)
                                let [c_before, c] = ['', '']
                              else
  232              0.001161     let [c_before, c] = matches[1:2]
  232              0.000217   endif
  232              0.004139   let plist = split(&matchpairs, '.\zs[:,]')
  232              0.000935   let i = index(plist, c)
  232              0.000348   if i < 0
                                " not found, in Insert mode try character before the cursor
  232              0.000854     if c_col > 1 && (mode() == 'i' || mode() == 'R')
   20              0.000058       let before = strlen(c_before)
   20              0.000034       let c = c_before
   20              0.000052       let i = index(plist, c)
   20              0.000016     endif
  232              0.000290     if i < 0
                                  " not found, nothing to do
  232              0.000280       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              " Build an expression that detects whether the current cursor position is in
                              " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                              " skip argument.
                              " We match "escape" for special items, such as lispEscapeSpecial.
                              let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                              " If executing the expression determines that the cursor is currently in
                              " one of the syntax types, then we want searchpairpos() to find the pair
                              " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                              " outside of the syntax types and s_skip should keep its value so we skip any
                              " matching pair inside the syntax types.
                              execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  gitgutter#hunk#hunks()
Called 12 times
Total time:   0.000272
 Self time:   0.000109

count  total (s)   self (s)
   12   0.000263   0.000100   return gitgutter#utility#getbufvar(gitgutter#utility#bufnr(), 'hunks', [])

FUNCTION  ale#highlight#UnqueueHighlights()
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000004     if has_key(s:buffer_highlights, a:buffer)
                                    call remove(s:buffer_highlights, a:buffer)
                                endif

FUNCTION  airline#parts#crypt()
Called 280 times
Total time:   0.002625
 Self time:   0.002625

count  total (s)   self (s)
  280              0.002424   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  192()
Called 1 time
Total time:   0.000026
 Self time:   0.000011

count  total (s)   self (s)
    1   0.000024   0.000010     let name = s:Creator.BufNamePrefix() . self._nextBufferNumber()
    1              0.000001     return name

FUNCTION  193()
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000003     if !exists("s:Creator._NextBufNum")
    1              0.000005         let s:Creator._NextBufNum = 1
    1              0.000001     else
                                    let s:Creator._NextBufNum += 1
                                endif
                            
    1              0.000001     return s:Creator._NextBufNum

FUNCTION  194()
Called 1 time
Total time:   0.000941
 Self time:   0.000080

count  total (s)   self (s)
    1              0.000003     let path = {}
    1   0.000555   0.000012     if g:NERDTreeBookmark.BookmarkExistsFor(a:str)
                                    let path = g:NERDTreeBookmark.BookmarkFor(a:str).path
                                else
    1              0.000004         let dir = a:str ==# '' ? getcwd() : a:str
                            
                                    "hack to get an absolute path if a relative path is given
    1              0.000006         if dir =~# '^\.'
                                        let dir = getcwd() . g:NERDTreePath.Slash() . dir
                                    endif
    1   0.000047   0.000019         let dir = g:NERDTreePath.Resolve(dir)
                            
    1              0.000001         try
    1   0.000300   0.000011             let path = g:NERDTreePath.New(dir)
    1              0.000001         catch /^NERDTree.InvalidArgumentsError/
                                        call nerdtree#echo("No bookmark or directory found for: " . a:str)
                                        return {}
                                    endtry
    1              0.000001     endif
    1              0.000001     if !path.isDirectory
                                    let path = path.getParent()
                                endif
                            
    1              0.000001     return path

FUNCTION  196()
Called 1 time
Total time:   0.027859
 Self time:   0.000376

count  total (s)   self (s)
                                "throwaway buffer options
    1              0.000294     setlocal noswapfile
    1              0.000012     setlocal buftype=nofile
    1              0.000003     setlocal bufhidden=hide
    1              0.000003     setlocal nowrap
    1              0.000003     setlocal foldcolumn=0
    1              0.000003     setlocal foldmethod=manual
    1              0.000002     setlocal nofoldenable
    1   0.000025   0.000004     setlocal nobuflisted
    1              0.000003     setlocal nospell
    1              0.000002     if g:NERDTreeShowLineNumbers
                                    setlocal nu
                                else
    1              0.000003         setlocal nonu
    1              0.000002         if v:version >= 703
    1              0.000003             setlocal nornu
    1              0.000001         endif
    1              0.000001     endif
                            
    1              0.000001     iabc <buffer>
                            
    1              0.000001     if g:NERDTreeHighlightCursorline
    1              0.000003         setlocal cursorline
    1              0.000001     endif
                            
    1   0.000020   0.000010     call self._setupStatusline()
    1   0.002203   0.000006     call self._bindMappings()
    1   0.025263   0.000008     setlocal filetype=nerdtree

FUNCTION  197()
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000003     if g:NERDTreeStatusline != -1
    1              0.000006         let &l:statusline = g:NERDTreeStatusline
    1              0.000001     endif

FUNCTION  199()
Called 1 time
Total time:   0.092631
 Self time:   0.000028

count  total (s)   self (s)
    1   0.000062   0.000013     let creator = s:Creator.New()
    1   0.092567   0.000014     call creator.toggleTabTree(a:dir)

FUNCTION  <SNR>90_get_section()
Called 59 times
Total time:   0.001514
 Self time:   0.001384

count  total (s)   self (s)
   59              0.000138   if has_key(s:section_truncate_width, a:key)
   38              0.000098     if winwidth(a:winnr) < s:section_truncate_width[a:key]
   21              0.000020       return ''
                                endif
   17              0.000011   endif
   38              0.000071   let spc = g:airline_symbols.space
   38              0.000154   if !exists('g:airline_section_{a:key}')
                                return ''
                              endif
   38   0.000387   0.000258   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
   38              0.000256   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
   38              0.000143   return empty(text) ? '' : prefix.text.suffix

FUNCTION  gitgutter#utility#strip_trailing_new_line()
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000017   return substitute(a:line, '\n$', '', '')

FUNCTION  <SNR>89_get_seperator()
Called 28 times
Total time:   0.023265
 Self time:   0.000487

count  total (s)   self (s)
   28   0.006514   0.000259   if s:should_change_group(a:prev_group, a:group)
   28   0.016729   0.000206     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
                                return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  <SNR>96_update_tags()
Called 2 times
Total time:   0.000179
 Self time:   0.000162

count  total (s)   self (s)
                                " Figure out where to save.
    2              0.000016     let l:buf_gutentags_files = getbufvar(a:bufno, 'gutentags_files')
    2              0.000008     let l:tags_file = l:buf_gutentags_files[a:module]
    2              0.000008     let l:proj_dir = getbufvar(a:bufno, 'gutentags_root')
                            
                                " Check that there's not already an update in progress.
    2              0.000006     let l:lock_file = l:tags_file . '.lock'
    2              0.000026     if filereadable(l:lock_file)
    2              0.000004         if a:queue_mode == 2
    2              0.000014             let l:idx = index(s:update_queue[a:module], l:tags_file)
    2              0.000003             if l:idx < 0
    1              0.000005                 call add(s:update_queue[a:module], l:tags_file)
    1              0.000001             endif
    2   0.000047   0.000029             call gutentags#trace("Tag file '" . l:tags_file . "' is already being updated. Queuing it up...")
    2              0.000003         elseif a:queue_mode == 1
                                        call gutentags#trace("Tag file '" . l:tags_file ."' is already being updated. Skipping...")
                                    elseif a:queue_mode == 0
                                        echom "gutentags: The tags file is already being updated, " ."please try again later."
                                    else
                                        call gutentags#throwerr("Unknown queue mode: " . a:queue_mode)
                                    endif
    2              0.000003         return
                                endif
                            
                                " Switch to the project root to make the command line smaller, and make
                                " it possible to get the relative path of the filename to parse if we're
                                " doing an incremental update.
                                let l:prev_cwd = getcwd()
                                call gutentags#chdir(fnameescape(l:proj_dir))
                                try
                                    call call("gutentags#".a:module."#generate",[l:proj_dir, l:tags_file, a:write_mode])
                                catch /^gutentags\:/
                                    echom "Error while generating ".a:module." file:"
                                    echom v:exception
                                finally
                                    " Restore the current directory...
                                    call gutentags#chdir(fnameescape(l:prev_cwd))
                                endtry

FUNCTION  gitgutter#hunk#increment_lines_modified()
Called 12 times
Total time:   0.000657
 Self time:   0.000246

count  total (s)   self (s)
   12   0.000090   0.000063   let bufnr = gitgutter#utility#bufnr()
   12   0.000302   0.000065   let summary = gitgutter#hunk#summary(bufnr)
   12              0.000030   let summary[1] += a:count
   12   0.000219   0.000073   call gitgutter#utility#setbufvar(bufnr, 'summary', summary)

FUNCTION  gitgutter#diff#process_modified_and_added()
Called 12 times
Total time:   0.002676
 Self time:   0.002676

count  total (s)   self (s)
   12              0.000028   let offset = 0
   24              0.000054   while offset < a:from_count
   12              0.000034     let line_number = a:to_line + offset
   12              0.000057     call add(a:modifications, [line_number, 'modified'])
   12              0.000028     let offset += 1
   12              0.000016   endwhile
   96              0.000263   while offset < a:to_count
   84              0.000190     let line_number = a:to_line + offset
   84              0.000307     call add(a:modifications, [line_number, 'added'])
   84              0.000144     let offset += 1
   84              0.001300   endwhile

FUNCTION  ale#Queue()
Called 24 times
Total time:   0.006368
 Self time:   0.001644

count  total (s)   self (s)
   24              0.000092     if len(a:0) > 1
                                    throw 'too many arguments!'
                                endif
                            
                                " Default linting_flag to ''
   24              0.000105     let l:linting_flag = get(a:000, 0, '')
                            
   24              0.000078     if l:linting_flag !=# '' && l:linting_flag !=# 'lint_file'
                                    throw "linting_flag must be either '' or 'lint_file'"
                                endif
                            
   24   0.001656   0.000129     if ale#ShouldDoNothing()
    1              0.000001         return
                                endif
                            
                                " Remember that we want to check files for this buffer.
                                " We will remember this until we finally run the linters, via any event.
   23              0.000060     if l:linting_flag ==# 'lint_file'
    5              0.000035         let s:should_lint_file_for_buffer[bufnr('%')] = 1
    5              0.000006     endif
                            
   23              0.000045     if s:lint_timer != -1
   20              0.000070         call timer_stop(s:lint_timer)
   20              0.000040         let s:lint_timer = -1
   20              0.000016     endif
                            
   23   0.002828   0.000181     let l:linters = ale#linter#Get(&filetype)
   23              0.000048     if len(l:linters) == 0
                                    " There are no linters to lint with, so stop here.
    2              0.000002         return
                                endif
                            
   21              0.000027     if a:delay > 0
   19              0.000118         let s:lint_timer = timer_start(a:delay, function('ale#Lint'))
   19              0.000016     else
    2   0.000560   0.000009         call ale#Lint()
    2              0.000001     endif

FUNCTION  gitgutter#hunk#increment_lines_added()
Called 12 times
Total time:   0.000843
 Self time:   0.000342

count  total (s)   self (s)
   12   0.000100   0.000070   let bufnr = gitgutter#utility#bufnr()
   12   0.000366   0.000066   let summary = gitgutter#hunk#summary(bufnr)
   12              0.000035   let summary[0] += a:count
   12   0.000316   0.000145   call gitgutter#utility#setbufvar(bufnr, 'summary', summary)

FUNCTION  gutentags#get_project_root()
Called 1 time
Total time:   0.000114
 Self time:   0.000092

count  total (s)   self (s)
    1              0.000002     if g:gutentags_project_root_finder != ''
                                    return call(g:gutentags_project_root_finder, [a:path])
                                endif
                            
    1   0.000018   0.000007     let l:path = gutentags#stripslash(a:path)
    1              0.000002     let l:previous_path = ""
    1              0.000004     let l:markers = g:gutentags_project_root[:]
    1              0.000002     if exists('g:ctrlp_root_markers')
                                    for crm in g:ctrlp_root_markers
                                        if index(l:markers, crm) < 0
                                            call add(l:markers, crm)
                                        endif
                                    endfor
                                endif
    1              0.000002     while l:path != l:previous_path
    1              0.000002         for root in l:markers
    1              0.000016             if !empty(globpath(l:path, root, 1))
    1              0.000007                 let l:proj_dir = simplify(fnamemodify(l:path, ':p'))
    1   0.000017   0.000005                 let l:proj_dir = gutentags#stripslash(l:proj_dir)
    1              0.000002                 if l:proj_dir == ''
                                                call gutentags#trace("Found project marker '" . root ."' at the root of your file-system! " ." That's probably wrong, disabling " ."gutentags for this file...",1)
                                                call gutentags#throw("Marker found at root, aborting.")
                                            endif
    2              0.000005                 for ign in g:gutentags_exclude_project_root
    1              0.000002                     if l:proj_dir == ign
                                                    call gutentags#trace("Ignoring project root '" . l:proj_dir ."' because it is in the list of ignored" ." projects.")
                                                    call gutentags#throw("Ignore project: " . l:proj_dir)
                                                endif
    1              0.000001                 endfor
    1              0.000001                 return l:proj_dir
                                        endif
                                    endfor
                                    let l:previous_path = l:path
                                    let l:path = fnamemodify(l:path, ':h')
                                endwhile
                                call gutentags#throw("Can't figure out what tag file to use for: " . a:path)

FUNCTION  gutentags#stripslash()
Called 3 times
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    3              0.000032     return fnamemodify(a:path, ':s?[/\\]$??')

FUNCTION  nerdtree#runningWindows()
Called 89 times
Total time:   0.000612
 Self time:   0.000612

count  total (s)   self (s)
   89              0.000578     return has("win16") || has("win32") || has("win64")

FUNCTION  <SNR>85_exec_separator()
Called 131 times
Total time:   0.064239
 Self time:   0.006940

count  total (s)   self (s)
  131              0.000278   if pumvisible()
                                return
                              endif
  131   0.017548   0.000881   let l:from = airline#themes#get_highlight(a:from.a:suffix)
  131   0.017896   0.000915   let l:to = airline#themes#get_highlight(a:to.a:suffix)
  131              0.000599   let group = a:from.'_to_'.a:to.a:suffix
  131              0.000180   if a:inverse
   36              0.000185     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
   36              0.000034   else
   95              0.000483     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
   95              0.000083   endif
  131              0.000713   let a:dict[group] = colors
  131   0.025220   0.001570   call airline#highlighter#exec(group, colors)

FUNCTION  gitgutter#all()
Called 8 times
Total time:   0.096948
 Self time:   0.001586

count  total (s)   self (s)
   16   0.000451   0.000249   for buffer_id in gitgutter#utility#dedup(tabpagebuflist())
    8              0.000900     let file = expand('#' . buffer_id . ':p')
    8              0.000045     if !empty(file)
    8   0.095361   0.000201       call gitgutter#process_buffer(buffer_id, 0)
    8              0.000028     endif
    8              0.000015   endfor

FUNCTION  gitgutter#utility#extension()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000003   return fnamemodify(s:file, ':e')

FUNCTION  airline#highlighter#highlight()
Called 13 times
Total time:   0.223370
 Self time:   0.033846

count  total (s)   self (s)
   13              0.000041   let bufnr = a:0 ? a:1 : ''
   13              0.000061   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
   13              0.000195   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
   13              0.000054   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
   35              0.000091   for mode in mapped
   22              0.000172     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
   13              0.000063       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
  204              0.000696       for kvp in items(dict)
  191              0.000476         let mode_colors = kvp[1]
  191              0.000432         let name = kvp[0]
  191              0.000673         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
    1              0.000002           let name = 'airline_c'.bufnr
    1              0.000001         endif
  191   0.046079   0.001760         call airline#highlighter#exec(name.suffix, mode_colors)
                            
  573              0.001502         for accent in keys(s:accents)
  382              0.001187           if !has_key(p.accents, accent)
                                        continue
                                      endif
  382              0.002004           let colors = copy(mode_colors)
  382              0.001177           if p.accents[accent][0] != ''
  191              0.000588             let colors[0] = p.accents[accent][0]
  191              0.000166           endif
  382              0.000889           if p.accents[accent][2] != ''
  191              0.000511             let colors[2] = p.accents[accent][2]
  191              0.000149           endif
  382              0.000732           if len(colors) >= 5
  382              0.001459             let colors[4] = get(p.accents[accent], 4, '')
  382              0.000337           else
                                        call add(colors, get(p.accents[accent], 4, ''))
                                      endif
  382   0.102959   0.003963           call airline#highlighter#exec(name.suffix.'_'.accent, colors)
  382              0.000478         endfor
  191              0.000176       endfor
                            
                                  " TODO: optimize this
  109              0.000404       for sep in items(s:separators)
   96   0.047772   0.001564         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
   96              0.000143       endfor
   13              0.000229     endif
   22              0.000024   endfor

FUNCTION  <SNR>90_add_section()
Called 44 times
Total time:   0.002531
 Self time:   0.001235

count  total (s)   self (s)
   44              0.000243     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
   44   0.000402   0.000210     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
    4              0.000003       return
                                endif
   40              0.000039     if condition
                                  call a:builder.add_raw('%(')
                                endif
   40   0.001441   0.000337     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
   40              0.000041     if condition
                                  call a:builder.add_raw('%)')
                                endif

FUNCTION  airline#extensions#ale#get_warnings()
Called 280 times
Total time:   0.019155
 Self time:   0.002800

count  total (s)   self (s)
  280   0.018276   0.001921   let l:count = s:count(1)
  280              0.000641   return l:count ? s:warning_symbol . l:count : ''

FUNCTION  gitgutter#utility#shellescape()
Called 37 times
Total time:   0.001202
 Self time:   0.000921

count  total (s)   self (s)
   37              0.000537   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
   25              0.000053     return a:arg
                              elseif &shell =~# 'cmd' || gitgutter#utility#using_xolox_shell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
                              else
   12              0.000053     return shellescape(a:arg)
                              endif

FUNCTION  gitgutter#sign#upsert_new_gitgutter_signs()
Called 12 times
Total time:   0.018841
 Self time:   0.017885

count  total (s)   self (s)
   12   0.000088   0.000063   let bufnr = gitgutter#utility#bufnr()
   12   0.000230   0.000078   let other_signs         = gitgutter#utility#getbufvar(bufnr, 'other_signs')
   12   0.000206   0.000082   let old_gitgutter_signs = gitgutter#utility#getbufvar(bufnr, 'gitgutter_signs')
                            
  108              0.000162   for line in a:modified_lines
   96              0.000211     let line_number = line[0]  " <number>
   96              0.000276     if index(other_signs, line_number) == -1  " don't clobber others' signs
   96   0.001183   0.000558       let name = gitgutter#utility#highlight_name_for_change(line[1])
   96              0.000285       if !has_key(old_gitgutter_signs, line_number)  " insert
    3   0.000061   0.000032         let id = gitgutter#sign#next_sign_id()
    3              0.014113         execute "sign place" id "line=" . line_number "name=" . name "buffer=" . bufnr
    3              0.000016       else  " update if sign has changed
   93              0.000301         let old_sign = old_gitgutter_signs[line_number]
   93              0.000205         if old_sign.name !=# name
                                      execute "sign place" old_sign.id "name=" . name "buffer=" . bufnr
                                    end
   93              0.000070       endif
   96              0.000070     endif
   96              0.000102   endfor
                              " At this point b:gitgutter_gitgutter_signs is out of date.

FUNCTION  nerdtree#compareNodesBySortKey()
Called 107 times
Total time:   0.009175
 Self time:   0.001113

count  total (s)   self (s)
  107   0.006779   0.000581     if a:n1.path.getSortKey() <# a:n2.path.getSortKey()
   40              0.000034         return -1
                                elseif a:n1.path.getSortKey() ># a:n2.path.getSortKey()
   67              0.000052         return 1
                                else
                                    return 0
                                endif

FUNCTION  gitgutter#async#available()
Called 12 times
Total time:   0.000077
 Self time:   0.000077

count  total (s)   self (s)
   12              0.000066   return s:available

FUNCTION  gitgutter#diff#parse_hunk()
Called 24 times
Total time:   0.001100
 Self time:   0.001100

count  total (s)   self (s)
   24              0.000503   let matches = matchlist(a:line, s:hunk_re)
   24              0.000076   if len(matches) > 0
   12              0.000059     let from_line  = str2nr(matches[1])
   12              0.000061     let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
   12              0.000043     let to_line    = str2nr(matches[3])
   12              0.000057     let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
   12              0.000052     return [from_line, from_count, to_line, to_count]
                              else
   12              0.000017     return []
                              end

FUNCTION  <SNR>5_LoadIndent()
Called 1 time
Total time:   0.001296
 Self time:   0.001296

count  total (s)   self (s)
    1              0.000005     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
                                endif
    1              0.000005     let s = expand("<amatch>")
    1              0.000003     if s != ""
    1              0.000002       if exists("b:did_indent")
                            	unlet b:did_indent
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    2              0.000012       for name in split(s, '\.')
    1              0.001250 	exe 'runtime! indent/' . name . '.vim'
    1              0.000004       endfor
    1              0.000002     endif

FUNCTION  airline#parts#get()
Called 2 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    2              0.000011   return get(s:parts, a:key, {})

FUNCTION  <SNR>40_repo_head()
Called 560 times
Total time:   0.100369
 Self time:   0.030270

count  total (s)   self (s)
  560   0.064599   0.005764     let head = s:repo().head_ref()
                            
  560              0.006765     if head =~# '^ref: '
  560   0.016250   0.004986       let branch = s:sub(head,'^ref: %(refs/%(heads/|remotes/|tags/)=)=','')
  560              0.001148     elseif head =~# '^\x\{40\}$'
                                  " truncate hash to a:1 characters if we're in detached head mode
                                  let len = a:0 ? a:1 : 0
                                  let branch = len ? head[0:len-1] : ''
                                else
                                  return ''
                                endif
                            
  560              0.000988     return branch

FUNCTION  <SNR>40_winshell()
Called 10 times
Total time:   0.000096
 Self time:   0.000096

count  total (s)   self (s)
   10              0.000090   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  airline#parts#paste()
Called 280 times
Total time:   0.001151
 Self time:   0.001151

count  total (s)   self (s)
  280              0.001004   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  <SNR>102_job_finished()
Called 12 times
Total time:   0.000127
 Self time:   0.000127

count  total (s)   self (s)
   12              0.000058   if has_key(s:jobs, a:id)
   12              0.000042     unlet s:jobs[a:id]
   12              0.000015   endif

FUNCTION  <SNR>102_is_job_started()
Called 12 times
Total time:   0.000079
 Self time:   0.000079

count  total (s)   self (s)
   12              0.000058   return has_key(s:jobs, a:id)

FUNCTION  airline#update_statusline()
Called 5 times
Total time:   0.043155
 Self time:   0.000496

count  total (s)   self (s)
    5   0.000047   0.000027   if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
                              endif
    8              0.000044   for nr in filter(range(1, winnr('$')), 'v:val != winnr()')
    3   0.000020   0.000011     if airline#util#getwinvar(nr, 'airline_disabled', 0)
                                  continue
                                endif
    3              0.000011     call setwinvar(nr, 'airline_active', 0)
    3              0.000014     let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
    3   0.012425   0.000051     call s:invoke_funcrefs(context, s:inactive_funcrefs)
    3              0.000004   endfor
                            
    5              0.000013   unlet! w:airline_render_left w:airline_render_right
    5              0.000078   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                            
    5              0.000010   let w:airline_active = 1
    5              0.000030   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
    5   0.030356   0.000100   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  gitgutter#utility#restore_shell()
Called 23 times
Total time:   0.000777
 Self time:   0.000777

count  total (s)   self (s)
   23              0.000116   if has('unix')
   23              0.000083     if exists('s:shell')
   23              0.000214       let &shell = s:shell
   23              0.000138       let &shellcmdflag = s:shellcmdflag
   23              0.000107       let &shellredir = s:shellredir
   23              0.000024     endif
   23              0.000019   endif

FUNCTION  gitgutter#sign#obsolete_gitgutter_signs_to_remove()
Called 12 times
Total time:   0.002183
 Self time:   0.001997

count  total (s)   self (s)
   12   0.000102   0.000065   let bufnr = gitgutter#utility#bufnr()
   12              0.000029   let signs_to_remove = []  " list of [<id (number)>, ...]
   12              0.000025   let remove_all_signs = 1
   12   0.000261   0.000113   let old_gitgutter_signs = gitgutter#utility#getbufvar(bufnr, 'gitgutter_signs')
  105              0.000447   for line_number in keys(old_gitgutter_signs)
   93              0.000381     if index(a:new_gitgutter_signs_line_numbers, str2nr(line_number)) == -1
                                  call add(signs_to_remove, old_gitgutter_signs[line_number].id)
                                else
   93              0.000163       let remove_all_signs = 0
   93              0.000083     endif
   93              0.000086   endfor
   12              0.000040   let s:remove_all_old_signs = remove_all_signs
   12              0.000024   return signs_to_remove

FUNCTION  ale#util#BinarySearch()
Called 191 times
Total time:   0.004931
 Self time:   0.004931

count  total (s)   self (s)
  191              0.000974     let l:min = 0
  191              0.000998     let l:max = len(a:loclist) - 1
  191              0.000523     let l:last_column_match = -1
                            
  191              0.000493     while 1
  191              0.000502         if l:max < l:min
  191              0.000480             return l:last_column_match
                                    endif
                            
                                    let l:mid = (l:min + l:max) / 2
                                    let l:obj = a:loclist[l:mid]
                            
                                    " Binary search to get on the same line
                                    if a:loclist[l:mid]['lnum'] < a:line
                                        let l:min = l:mid + 1
                                    elseif a:loclist[l:mid]['lnum'] > a:line
                                        let l:max = l:mid - 1
                                    else
                                        let l:last_column_match = l:mid
                            
                                        " Binary search to get the same column, or near it
                                        if a:loclist[l:mid]['col'] < a:column
                                            let l:min = l:mid + 1
                                        elseif a:loclist[l:mid]['col'] > a:column
                                            let l:max = l:mid - 1
                                        else
                                            return l:mid
                                        endif
                                    endif
                                endwhile

FUNCTION  <SNR>40_repo_head_ref()
Called 560 times
Total time:   0.041870
 Self time:   0.032552

count  total (s)   self (s)
  560   0.015010   0.009636   if !filereadable(self.dir('HEAD'))
                                return ''
                              endif
  560   0.024864   0.020919   return readfile(self.dir('HEAD'))[0]

FUNCTION  airline#parts#readonly()
Called 303 times
Total time:   0.002967
 Self time:   0.002967

count  total (s)   self (s)
  303              0.001335   if &readonly && &modifiable && !filereadable(bufname('%'))
                                return '[noperm]'
                              else
  303              0.000627     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  gitgutter#utility#directory_of_file()
Called 13 times
Total time:   0.000072
 Self time:   0.000072

count  total (s)   self (s)
   13              0.000064   return fnamemodify(s:file, ':h')

FUNCTION  airline#extensions#apply_left_override()
Called 2 times
Total time:   0.000794
 Self time:   0.000060

count  total (s)   self (s)
    2              0.000021   let w:airline_section_a = a:section1
    2              0.000005   let w:airline_section_b = a:section2
    2   0.000755   0.000021   let w:airline_section_c = airline#section#create(['readonly'])
    2              0.000005   let w:airline_render_left = 1
    2              0.000004   let w:airline_render_right = 0

FUNCTION  nerdtree#has_opt()
Called 5 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    5              0.000021     return has_key(a:options, a:name) && a:options[a:name] == 1

FUNCTION  airline#highlighter#exec()
Called 710 times
Total time:   0.168785
 Self time:   0.052830

count  total (s)   self (s)
  710              0.001321   if pumvisible()
                                return
                              endif
  710              0.001359   let colors = a:colors
  710              0.000915   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
                              endif
  710   0.081482   0.004621   let old_hi = airline#highlighter#get_highlight(a:group)
  710              0.001691   if len(colors) == 4
  131              0.000368     call add(colors, '')
  131              0.000110   endif
  710   0.016289   0.004241   let colors = s:CheckDefined(colors)
  710              0.002114   if old_hi != colors || !hlexists(a:group)
  513   0.044069   0.017023     let cmd = printf('hi %s %s %s %s %s %s %s %s', a:group, s:Get(colors, 0, 'guifg=', ''), s:Get(colors, 1, 'guibg=', ''), s:Get(colors, 2, 'ctermfg=', ''), s:Get(colors, 3, 'ctermbg=', ''), s:Get(colors, 4, 'gui=', ''), s:Get(colors, 4, 'cterm=', ''), s:Get(colors, 4, 'term=', ''))
  513              0.005262     exe cmd
  513              0.000471   endif

FUNCTION  gitgutter#utility#setbufvar()
Called 113 times
Total time:   0.002131
 Self time:   0.002131

count  total (s)   self (s)
  113              0.000712   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
  113              0.000783   let dict[a:varname] = a:val
  113              0.000504   call setbufvar(a:buffer, 'gitgutter', dict)

FUNCTION  <SNR>40_buffer_getline()
Called 6 times
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    6              0.000045   return get(getbufline(self['#'], a:lnum), 0, '')

FUNCTION  airline#extensions#whitespace#check()
Called 280 times
Total time:   0.051763
 Self time:   0.030768

count  total (s)   self (s)
  280              0.002171   if &readonly || !&modifiable || !s:enabled || line('$') > s:max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
                              endif
                            
  280              0.000945   if !exists('b:airline_whitespace_check')
    8              0.000022     let b:airline_whitespace_check = ''
    8              0.000057     let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
    8              0.000014     let trailing = 0
    8              0.000026     if index(checks, 'trailing') > -1
    8              0.000011       try
    8              0.000032         let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
    8              0.000529         let trailing = search(regexp, 'nw')
    8              0.000010       catch
                                    echomsg 'airline#whitespace: error occured evaluating '. regexp
                                    echomsg v:exception
                                    return ''
                                  endtry
    8              0.000006     endif
                            
    8              0.000013     let mixed = 0
    8              0.000013     let check = 'indent'
    8              0.000086     if index(checks, check) > -1 && index(get(s:skip_check_ft, &ft, []), check) < 0
    8   0.002827   0.000125       let mixed = s:check_mixed_indent()
    8              0.000016     endif
                            
    8              0.000019     let mixed_file = ''
    8              0.000015     let check = 'mixed-indent-file'
    8              0.000090     if index(checks, check) > -1 && index(get(s:skip_check_ft, &ft, []), check) < 0
    8   0.001003   0.000069       let mixed_file = s:check_mixed_indent_file()
    8              0.000007     endif
                            
    8              0.000013     let long = 0
    8              0.000024     if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
    8              0.000023     if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file)
    8              0.000024       let b:airline_whitespace_check = s:symbol
    8              0.000018       if strlen(s:symbol) > 0
    8              0.000023         let space = (g:airline_symbols.space)
    8              0.000007       else
                                    let space = ''
                                  endif
                            
    8              0.000010       if s:show_message
    8              0.000010         if trailing != 0
    8              0.000058           let b:airline_whitespace_check .= space.printf(s:trailing_format, trailing)
    8              0.000007         endif
    8              0.000010         if mixed != 0
                                      let b:airline_whitespace_check .= space.printf(s:mixed_indent_format, mixed)
                                    endif
    8              0.000009         if long != 0
                                      let b:airline_whitespace_check .= space.printf(s:long_format, long)
                                    endif
    8              0.000017         if !empty(mixed_file)
                                      let b:airline_whitespace_check .= space.printf(s:mixed_indent_file_format, mixed_file)
                                    endif
    8              0.000005       endif
    8              0.000005     endif
    8              0.000005   endif
  280   0.019367   0.002009   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  nerdtree#exec()
Called 2 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    2              0.000009     let old_ei = &ei
    2              0.000010     set ei=all
    2              0.000007     exec a:cmd
    2              0.000008     let &ei = old_ei

FUNCTION  <SNR>4_LoadFTPlugin()
Called 1 time
Total time:   0.011175
 Self time:   0.011175

count  total (s)   self (s)
    1              0.000009     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
                                endif
                            
    1              0.000004     let s = expand("<amatch>")
    1              0.000002     if s != ""
    1              0.000022       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    2              0.000015       for name in split(s, '\.')
    1              0.011096 	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
    1              0.000004       endfor
    1              0.000001     endif

FUNCTION  <SNR>80_reset_untracked_cache()
Called 2 times
Total time:   0.000393
 Self time:   0.000286

count  total (s)   self (s)
                              " shellcmdpost - whether function was called as a result of ShellCmdPost hook
    2              0.000015   if !s:has_async && !has('nvim')
                                if a:shellcmdpost
                                  " Clear cache only if there was no error or the script uses an
                                  " asynchronous interface. Otherwise, cache clearing would overwrite
                                  " v:shell_error with a system() call inside get_*_untracked.
                                  if v:shell_error
                                    return
                                  endif
                                endif
                              endif
                            
    2              0.000092   let l:file = expand("%:p")
    6              0.000029   for vcs in keys(s:vcs_config)
                                " Dump the value of the cache for the current file. Partially mitigates the
                                " issue of cache invalidation happening before a call to
                                " s:update_untracked()
    4   0.000148   0.000041     call s:update_untracked_in_buffer_config(l:file, l:vcs)
    4              0.000051     let s:vcs_config[vcs].untracked = {}
    4              0.000006   endfor

FUNCTION  <SNR>40_buffer()
Called 6 times
Total time:   0.000340
 Self time:   0.000300

count  total (s)   self (s)
    6              0.000051   let buffer = {'#': bufnr(a:0 ? a:1 : '%')}
    6              0.000162   call extend(extend(buffer,s:buffer_prototype,'keep'),s:abstract_prototype,'keep')
    6   0.000105   0.000065   if buffer.getvar('git_dir') !=# ''
    6              0.000012     return buffer
                              endif
                              call s:throw('not a git repository: '.expand('%:p'))

FUNCTION  <SNR>40_repo_dir()
Called 1120 times
Total time:   0.009318
 Self time:   0.009318

count  total (s)   self (s)
 1120              0.008639   return join([self.git_dir]+a:000,'/')

FUNCTION  <SNR>107_StopCursorTimer()
Called 207 times
Total time:   0.002892
 Self time:   0.002892

count  total (s)   self (s)
  207              0.000666     if s:cursor_timer != -1
  197              0.000850         call timer_stop(s:cursor_timer)
  197              0.000729         let s:cursor_timer = -1
  197              0.000244     endif

FUNCTION  <SNR>79_is_branch_empty()
Called 280 times
Total time:   1.800454
 Self time:   0.003414

count  total (s)   self (s)
  280   1.800289   0.003249   return exists('*airline#extensions#branch#head') && empty(airline#extensions#branch#head())

FUNCTION  gitgutter#utility#full_path_to_directory_of_file()
Called 33 times
Total time:   0.001747
 Self time:   0.001747

count  total (s)   self (s)
   33              0.001715   return fnamemodify(s:file, ':p:h')

FUNCTION  ale#cleanup#Buffer()
Called 3 times
Total time:   0.001956
 Self time:   0.001441

count  total (s)   self (s)
    3              0.000013     if has_key(g:ale_buffer_info, a:buffer)
    1   0.000104   0.000016         call ale#engine#RemoveManagedFiles(a:buffer)
                            
                                    " When buffers are removed, clear all of the jobs.
    1              0.000004         for l:job in get(g:ale_buffer_info[a:buffer], 'job_list', [])
                                        call ale#engine#ClearJob(l:job)
                                    endfor
                            
                                    " Clear delayed highlights for a buffer being removed.
    1              0.000002         if g:ale_set_highlights
    1   0.001761   0.001334             call ale#highlight#UnqueueHighlights(a:buffer)
    1              0.000001         endif
                            
    1              0.000018         call remove(g:ale_buffer_info, a:buffer)
    1              0.000001     endif

FUNCTION  <SNR>107_FindItemAtCursor()
Called 191 times
Total time:   0.014067
 Self time:   0.009136

count  total (s)   self (s)
  191              0.002931     let l:info = get(g:ale_buffer_info, bufnr('%'), {'loclist': []})
  191              0.001466     let l:pos = getcurpos()
  191   0.007691   0.002760     let l:index = ale#util#BinarySearch(l:info.loclist, l:pos[1], l:pos[2])
  191              0.000905     let l:loc = l:index >= 0 ? l:info.loclist[l:index] : {}
                            
  191              0.000517     return [l:info, l:loc]

FUNCTION  airline#parts#spell()
Called 280 times
Total time:   0.001093
 Self time:   0.001093

count  total (s)   self (s)
  280              0.000955   return g:airline_detect_spell && &spell ? g:airline_symbols.spell : ''

FUNCTION  ale#Lint()
Called 15 times
Total time:   0.010179
 Self time:   0.001919

count  total (s)   self (s)
   15   0.002375   0.000630     if ale#ShouldDoNothing()
                                    return
                                endif
                            
   15              0.000091     let l:buffer = bufnr('%')
   15   0.002599   0.000148     let l:linters = ale#linter#Get(&filetype)
   15              0.000039     let l:should_lint_file = 0
                            
                                " Check if we previously requested checking the file.
   15              0.000072     if has_key(s:should_lint_file_for_buffer, l:buffer)
    3              0.000009         unlet s:should_lint_file_for_buffer[l:buffer]
    3              0.000006         let l:should_lint_file = 1
    3              0.000003     endif
                            
                                " Initialise the buffer information if needed.
   15   0.000327   0.000113     call ale#engine#InitBufferInfo(l:buffer)
                            
                                " Clear the new loclist again, so we will work with all new items.
   15              0.000072     let g:ale_buffer_info[l:buffer].new_loclist = []
                            
   15              0.000024     if l:should_lint_file
                                    " Clear loclist items for files if we are checking files again.
    3              0.000009         let g:ale_buffer_info[l:buffer].lint_file_loclist = []
    3              0.000002     else
                                    " Otherwise, don't run any `lint_file` linters
                                    " We will continue running any linters which are currently checking
                                    " the file, and the items will be mixed together with any new items.
   12              0.000083         call filter(l:linters, '!v:val.lint_file')
   12              0.000012     endif
                            
   30              0.000063     for l:linter in l:linters
   15   0.003972   0.000123         call ale#engine#Invoke(l:buffer, l:linter)
   15              0.000022     endfor

FUNCTION  gitgutter#hunk#summary()
Called 304 times
Total time:   0.007053
 Self time:   0.002822

count  total (s)   self (s)
  304   0.006841   0.002610   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  ale#linter#GetAll()
Called 36 times
Total time:   0.000503
 Self time:   0.000503

count  total (s)   self (s)
   36              0.000089     if a:filetype ==# ''
                                    " Empty filetype? Nothing to be done about that.
                                    return []
                                endif
                            
   36              0.000123     if has_key(s:linters, a:filetype)
                                    " We already loaded the linter files for this filetype, so stop here.
   36              0.000096         return s:linters[a:filetype]
                                endif
                            
                                " Load all linters for a given filetype.
                                execute 'silent! runtime! ale_linters/' . a:filetype . '/*.vim'
                            
                                if !has_key(s:linters, a:filetype)
                                    " If we couldn't load any linters, let everyone know.
                                    let s:linters[a:filetype] = []
                                endif
                            
                                return s:linters[a:filetype]

FUNCTION  <SNR>83_update()
Called 212 times
Total time:   0.010489
 Self time:   0.010489

count  total (s)   self (s)
  212              0.004615   if match(&ft, get(g:, 'airline#extensions#wordcount#filetypes')) > -1
                                let l:mode = mode()
                                if l:mode ==# 'v' || l:mode ==# 'V' || l:mode ==# 's' || l:mode ==# 'S'
                                  let b:airline_wordcount = airline#extensions#wordcount#formatters#{s:formatter}#format()
                                  let b:airline_change_tick = b:changedtick
                                else
                                  if get(b:, 'airline_wordcount_cache', '') is# '' || b:airline_wordcount_cache isnot# get(b:, 'airline_wordcount', '') || get(b:, 'airline_change_tick', 0) != b:changedtick
                                    " cache data
                                    let b:airline_wordcount = airline#extensions#wordcount#formatters#{s:formatter}#format()
                                    let b:airline_wordcount_cache = b:airline_wordcount
                                    let b:airline_change_tick = b:changedtick
                                  endif
                                endif
                              endif

FUNCTION  191()
Called 1 time
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    1              0.000043     let newCreator = copy(self)
    1              0.000004     return newCreator

FUNCTION  <SNR>80_update_untracked()
Called 560 times
Total time:   1.683760
 Self time:   0.060286

count  total (s)   self (s)
  560              0.021230   let l:file = expand("%:p")
  560              0.004083   if empty(l:file) || isdirectory(l:file)
                                return
                              endif
                            
  560              0.001256   let l:needs_update = 1
 1680              0.004359   for vcs in keys(s:vcs_config)
 1120              0.004456     if has_key(s:vcs_config[vcs].untracked, l:file)
 1116              0.002025       let l:needs_update = 0
 1116   0.026307   0.007992       call s:update_untracked_in_buffer_config(l:file, vcs)
 1116              0.000997     endif
 1120              0.001005   endfor
                            
  560              0.001001   if !l:needs_update
  558              0.000582     return
                              endif
                            
    6              0.000025   for vcs in keys(s:vcs_config)
    4              0.000016     let l:config = s:vcs_config[vcs]
    4              0.000007     if s:has_async
                                  " Note that asynchronous update updates s:vcs_config only, and only
                                  " s:update_untracked updates b:buffer_vcs_config. If s:vcs_config is
                                  " invalidated again before s:update_untracked is called, then we lose the
                                  " result of the previous call, i.e. the head string is not updated. It
                                  " doesn't happen often in practice, so we let it be.
                                  call s:get_vcs_untracked_async(l:config, l:file)
                                else
    4   1.605220   0.000176       let output = airline#util#system(l:config.cmd . shellescape(l:file))
    4              0.000137       if output =~? ('^' . l:config.untracked_mark)
                                    let l:config.untracked[l:file] = get(g:, 'airline#extensions#branch#notexists', g:airline_symbols.notexists)
                                  else
    4              0.000038         let l:config.untracked[l:file] = ''
    4              0.000005       endif
    4   0.000199   0.000084       call s:update_untracked_in_buffer_config(l:file, vcs)
    4              0.000004     endif
    4              0.000011   endfor

FUNCTION  ale#linter#ResolveFiletype()
Called 36 times
Total time:   0.000541
 Self time:   0.000541

count  total (s)   self (s)
                                " Try and get an aliased file type either from the user's Dictionary, or
                                " our default Dictionary, otherwise use the filetype as-is.
   36              0.000376     let l:filetype = get(   g:ale_linter_aliases,   a:original_filetype,   get(       s:default_ale_linter_aliases,       a:original_filetype,       a:original_filetype   ))
                            
   36              0.000061     return l:filetype

FUNCTION  ale#engine#RemoveManagedFiles()
Called 1 time
Total time:   0.000088
 Self time:   0.000046

count  total (s)   self (s)
    1              0.000003     if !has_key(g:ale_buffer_info, a:buffer)
                                    return
                                endif
                            
                                " We can't delete anything in a sandbox, so wait until we escape from
                                " it to delete temporary files and directories.
    1   0.000051   0.000009     if ale#util#InSandbox()
                                    return
                                endif
                            
                                " Delete files with a call akin to a plan `rm` command.
    1              0.000005     for l:filename in g:ale_buffer_info[a:buffer].temporary_file_list
                                    call delete(l:filename)
                                endfor
                            
    1              0.000005     let g:ale_buffer_info[a:buffer].temporary_file_list = []
                            
                                " Delete directories like `rm -rf`.
                                " Directories are handled differently from files, so paths that are
                                " intended to be single files can be set up for automatic deletion without
                                " accidentally deleting entire directories.
    1              0.000003     for l:directory in g:ale_buffer_info[a:buffer].temporary_directory_list
                                    call delete(l:directory, 'rf')
                                endfor
                            
    1              0.000003     let g:ale_buffer_info[a:buffer].temporary_directory_list = []

FUNCTION  nerdtree#checkForBrowse()
Called 3 times
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
    3              0.000028     if !isdirectory(a:dir)
    3              0.000005         return
                                endif
                            
                                if s:reuseWin(a:dir)
                                    return
                                endif
                            
                                call g:NERDTreeCreator.CreateWindowTree(a:dir)

FUNCTION  200()
Called 1 time
Total time:   0.092553
 Self time:   0.000046

count  total (s)   self (s)
    1   0.000022   0.000014     if g:NERDTree.ExistsForTab()
                                    if !g:NERDTree.IsOpen()
                                        call self._createTreeWin()
                                        if !&hidden
                                            call b:NERDTree.render()
                                        endif
                                        call b:NERDTree.ui.restoreScreenState()
                                    else
                                        call g:NERDTree.Close()
                                    endif
                                else
    1   0.092510   0.000012         call self.createTabTree(a:dir)
    1              0.000001     endif

FUNCTION  205()
Called 25 times
Total time:   0.000184
 Self time:   0.000184

count  total (s)   self (s)
   25              0.000099     let newObj = copy(self)
   25              0.000043     let newObj._flags = {}
   25              0.000025     return newObj

FUNCTION  207()
Called 24 times
Total time:   0.000233
 Self time:   0.000233

count  total (s)   self (s)
   24              0.000030     let flagstring = ""
   24              0.000053     for i in values(self._flags)
                                    let flagstring .= join(i)
                                endfor
                            
   24              0.000040     if len(flagstring) == 0
   24              0.000019         return ""
                                endif
                            
                                return '[' . flagstring . ']'

FUNCTION  gitgutter#utility#bufnr()
Called 193 times
Total time:   0.000545
 Self time:   0.000545

count  total (s)   self (s)
  193              0.000415   return s:bufnr

FUNCTION  ale#util#InSandbox()
Called 246 times
Total time:   0.016766
 Self time:   0.016766

count  total (s)   self (s)
  246              0.000758     try
  246              0.003679         call setbufvar('%', '', '')
                                catch /^Vim\%((\a\+)\)\=:E48/
                                    " E48 is the sandbox error.
                                    return 1
                                catch
                                    " If we're not in a sandbox, we'll get another error about an
                                    " invalid buffer variable name.
  246              0.000850     endtry
                            
  246              0.000458     return 0

FUNCTION  ale#engine#Invoke()
Called 15 times
Total time:   0.003849
 Self time:   0.003229

count  total (s)   self (s)
                                " Stop previous jobs for the same linter.
   15   0.000760   0.000140     call s:StopPreviousJobs(a:buffer, a:linter)
                            
   15              0.000103     let l:executable = has_key(a:linter, 'executable_callback')   ? ale#util#GetFunction(a:linter.executable_callback)(a:buffer)   : a:linter.executable
                            
                                " Run this program if it can be executed.
   15              0.002851     if executable(l:executable)
                                    call s:InvokeChain(a:buffer, a:linter, 0, [])
                                endif

FUNCTION  213()
Called 1 time
Total time:   0.000166
 Self time:   0.000055

count  total (s)   self (s)
    1   0.000086   0.000029     call g:NERDTree.MustBeOpen()
    1   0.000065   0.000011     call nerdtree#exec(g:NERDTree.GetWinNum() . "wincmd w")

FUNCTION  214()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002     return exists("b:NERDTree")

FUNCTION  215()
Called 2 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    2              0.000008     if !exists("t:NERDTreeBufName")
    2              0.000003         return
                                end
                            
                                "check b:NERDTree is still there and hasn't been e.g. :bdeleted
                                return !empty(getbufvar(bufnr(t:NERDTreeBufName), 'NERDTree'))

FUNCTION  219()
Called 3 times
Total time:   0.000099
 Self time:   0.000099

count  total (s)   self (s)
    3              0.000017     if exists("t:NERDTreeBufName")
    3              0.000079         return bufwinnr(t:NERDTreeBufName)
                                endif
                            
                                return -1

FUNCTION  fugitive#is_git_dir()
Called 4 times
Total time:   0.000156
 Self time:   0.000103

count  total (s)   self (s)
    4   0.000092   0.000039   let path = s:sub(a:path, '[\/]$', '') . '/'
    4              0.000060   return getfsize(path.'HEAD') > 10 && ( isdirectory(path.'objects') && isdirectory(path.'refs') || getftype(path.'commondir') ==# 'file')

FUNCTION  <SNR>40_repo()
Called 1120 times
Total time:   0.039099
 Self time:   0.039099

count  total (s)   self (s)
 1120              0.008668   let dir = a:0 ? a:1 : (exists('b:git_dir') && b:git_dir !=# '' ? b:git_dir : fugitive#extract_git_dir(expand('%:p')))
 1120              0.002160   if dir !=# ''
 1120              0.003358     if has_key(s:repos, dir)
 1120              0.003496       let repo = get(s:repos, dir)
 1120              0.001061     else
                                  let repo = {'git_dir': dir}
                                  let s:repos[dir] = repo
                                endif
 1120              0.013280     return extend(extend(repo, s:repo_prototype, 'keep'), s:abstract_prototype, 'keep')
                              endif
                              call s:throw('not a git repository: '.expand('%:p'))

FUNCTION  airline#extensions#branch#head()
Called 560 times
Total time:   1.959160
 Self time:   0.017289

count  total (s)   self (s)
  560              0.001966   if !exists('b:buffer_vcs_config')
                                call s:init_buffer()
                              endif
                            
  560   0.261145   0.003426   call s:update_branch()
  560   1.687264   0.003504   call s:update_untracked()
                            
  560              0.002771   if exists('b:airline_head') && !empty(b:airline_head)
  554              0.000943     return b:airline_head
                              endif
                            
    6              0.000011   let b:airline_head = ''
    6              0.000030   let l:vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])
                            
    6              0.000011   let l:heads = {}
   18              0.000026   for vcs in l:vcs_priority
   12              0.000033     if !empty(b:buffer_vcs_config[vcs].branch)
    6              0.000021       let l:heads[vcs] = b:buffer_vcs_config[vcs].branch
    6              0.000005     endif
   12              0.000008   endfor
                            
   12              0.000024   for vcs in keys(l:heads)
    6              0.000012     if !empty(b:airline_head)
                                  let b:airline_head .= ' | '
                                endif
    6   0.000077   0.000063     let b:airline_head .= (len(l:heads) > 1 ? s:vcs_config[l:vcs].exe : '') . s:format_name(l:heads[l:vcs])
    6              0.000020     let b:airline_head .= b:buffer_vcs_config[vcs].untracked
    6              0.000005   endfor
                            
    6              0.000009   if empty(l:heads)
                                if s:has_vcscommand
                                  call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                  endif
                                endif
                              endif
                            
    6              0.000019   if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if len(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = b:airline_head[0:(w:displayed_head_limit - 1)].(&encoding ==? 'utf-8' ?  '…' : '.')
                                endif
                              endif
                            
    6   0.000238   0.000039   if has_key(l:heads, 'git') && !s:check_in_path()
                                let b:airline_head = ''
                              endif
    6              0.000027   let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
    6   0.000214   0.000035   let b:airline_head = airline#util#shorten(b:airline_head, 120, minwidth)
    6              0.000008   return b:airline_head

FUNCTION  gitgutter#diff#run_diff()
Called 12 times
Total time:   0.140838
 Self time:   0.022285

count  total (s)   self (s)
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
   12              0.000034   let cmd = '('
                            
   12   0.000137   0.000070   let bufnr = gitgutter#utility#bufnr()
   12   0.001592   0.000110   let tracked = gitgutter#utility#getbufvar(bufnr, 'tracked', 0)  " i.e. tracked by git
   12              0.000021   if !tracked
                                " Don't bother trying to realtime-diff an untracked file.
                                " NOTE: perhaps we should pull this guard up to the caller?
                                if a:realtime
                                  throw 'diff failed'
                                else
                                  let cmd .= g:gitgutter_git_executable.' ls-files --error-unmatch '.gitgutter#utility#shellescape(gitgutter#utility#filename()).' && ('
                                endif
                              endif
                            
   12              0.000018   if a:realtime
    1   0.020256   0.000033     let blob_name = g:gitgutter_diff_base.':'.gitgutter#utility#shellescape(gitgutter#utility#file_relative_to_repo_root())
    1              0.000002     let blob_file = s:temp_index
    1              0.000002     let buff_file = s:temp_buffer
    1   0.000012   0.000008     let extension = gitgutter#utility#extension()
    1              0.000002     if !empty(extension)
    1              0.000003       let blob_file .= '.'.extension
    1              0.000003       let buff_file .= '.'.extension
    1              0.000001     endif
    1              0.000006     let cmd .= g:gitgutter_git_executable.' show '.blob_name.' > '.blob_file.' && '
                            
                                " Writing the whole buffer resets the '[ and '] marks and also the
                                " 'modified' flag (if &cpoptions includes '+').  These are unwanted
                                " side-effects so we save and restore the values ourselves.
    1              0.000007     let modified      = getbufvar(bufnr, "&mod")
    1              0.000005     let op_mark_start = getpos("'[")
    1              0.000003     let op_mark_end   = getpos("']")
                            
    1              0.016991     execute 'keepalt noautocmd silent write!' buff_file
                            
    1              0.000029     call setbufvar(bufnr, "&mod", modified)
    1              0.000005     call setpos("'[", op_mark_start)
    1              0.000002     call setpos("']", op_mark_end)
    1              0.000002   endif
                            
   12              0.000059   let cmd .= g:gitgutter_git_executable
   12              0.000023   if s:c_flag
   12              0.000039     let cmd .= ' -c "diff.autorefreshindex=0"'
   12              0.000036     let cmd .= ' -c "diff.noprefix=false"'
   12              0.000012   endif
   12              0.000075   let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' '
                            
   12              0.000017   if a:realtime
    1              0.000005     let cmd .= ' -- '.blob_file.' '.buff_file
    1              0.000001   else
   11   0.000531   0.000212     let cmd .= g:gitgutter_diff_base.' -- '.gitgutter#utility#shellescape(gitgutter#utility#filename())
   11              0.000014   endif
                            
   12              0.000060   if !a:preserve_full_diff && s:grep_available
   12   0.000833   0.000128     let cmd .= ' | '.s:grep_command.' '.gitgutter#utility#shellescape('^@@ ')
   12              0.000015   endif
                            
   12              0.000036   if (!a:preserve_full_diff && s:grep_available) || a:realtime
                                " grep exits with 1 when no matches are found; diff exits with 1 when
                                " differences are found.  However we want to treat non-matches and
                                " differences as non-erroneous behaviour; so we OR the command with one
                                " which always exits with success (0).
   12              0.000037     let cmd .= ' || exit 0'
   12              0.001909   endif
                            
   12              0.000042   let cmd .= ')'
                            
   12              0.000019   if !tracked
                                let cmd .= ')'
                              endif
                            
   12   0.000554   0.000121   let cmd = gitgutter#utility#command_in_directory_of_file(cmd)
                            
   12   0.000175   0.000098   if g:gitgutter_async && gitgutter#async#available() && !a:preserve_full_diff
   12   0.095484   0.000239     call gitgutter#async#execute(cmd)
   12              0.000061     return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if gitgutter#utility#shell_error()
                                  " A shell error indicates the file is not tracked by git (unless something bizarre is going on).
                                  throw 'diff failed'
                                endif
                            
                                return diff
                              endif

FUNCTION  <SNR>40_buffer_spec()
Called 8 times
Total time:   0.000474
 Self time:   0.000281

count  total (s)   self (s)
    8              0.000038     let bufname = bufname(self['#'])
    8   0.000429   0.000236     return s:shellslash(bufname == '' ? '' : fnamemodify(bufname,':p'))

FUNCTION  220()
Called 2 times
Total time:   0.000092
 Self time:   0.000024

count  total (s)   self (s)
    2   0.000090   0.000022     return s:NERDTree.GetWinNum() != -1

FUNCTION  223()
Called 1 time
Total time:   0.000057
 Self time:   0.000013

count  total (s)   self (s)
    1   0.000052   0.000008     if !s:NERDTree.IsOpen()
                                    throw "NERDTree.TreeNotOpen"
                                endif

FUNCTION  224()
Called 1 time
Total time:   0.000117
 Self time:   0.000034

count  total (s)   self (s)
    1              0.000013     let newObj = copy(self)
    1   0.000040   0.000009     let newObj.ui = g:NERDTreeUI.New(newObj)
    1   0.000060   0.000009     let newObj.root = g:NERDTreeDirNode.New(a:path, newObj)
    1              0.000002     let newObj._type = a:type
    1              0.000001     return newObj

FUNCTION  225()
Called 48 times
Total time:   0.000248
 Self time:   0.000248

count  total (s)   self (s)
   48              0.000097     if !exists('s:NERDTree._PathFilters')
    1              0.000002         let s:NERDTree._PathFilters = []
    1              0.000001     endif
   48              0.000051     return s:NERDTree._PathFilters

FUNCTION  228()
Called 1 time
Total time:   0.009054
 Self time:   0.000011

count  total (s)   self (s)
    1   0.009053   0.000010     call self.ui.render()

FUNCTION  gitgutter#diff#is_modified_and_added()
Called 12 times
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
   12              0.000040   return a:from_count > 0 && a:to_count > 0 && a:from_count < a:to_count

FUNCTION  GitGutterGetHunkSummary()
Called 280 times
Total time:   0.008451
 Self time:   0.001936

count  total (s)   self (s)
  280   0.008264   0.001749   return gitgutter#hunk#summary(winbufnr(0))

FUNCTION  airline#parts#mode()
Called 280 times
Total time:   0.009200
 Self time:   0.003083

count  total (s)   self (s)
  280   0.008968   0.002852   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  <SNR>40_shellslash()
Called 10 times
Total time:   0.000224
 Self time:   0.000127

count  total (s)   self (s)
   10   0.000149   0.000053   if s:winshell()
                                return s:gsub(a:path,'\\','/')
                              else
   10              0.000018     return a:path
                              endif

FUNCTION  gitgutter#utility#stringify()
Called 12 times
Total time:   0.000344
 Self time:   0.000344

count  total (s)   self (s)
   12              0.000315   return join(a:list, "\n")."\n"

FUNCTION  230()
Called 1 time
Total time:   0.000157
 Self time:   0.000153

count  total (s)   self (s)
    1   0.000007   0.000006     if self.getShowHelp()
                                    let help  = "\" NERD tree (" . nerdtree#version() . ") quickhelp~\n"
                                    let help .= "\" ============================\n"
                                    let help .= "\" File node mappings~\n"
                                    let help .= "\" ". (g:NERDTreeMouseMode ==# 3 ? "single" : "double") ."-click,\n"
                                    let help .= "\" <CR>,\n"
                                    if self.nerdtree.isTabTree()
                                        let help .= "\" ". g:NERDTreeMapActivateNode .": open in prev window\n"
                                    else
                                        let help .= "\" ". g:NERDTreeMapActivateNode .": open in current window\n"
                                    endif
                                    if self.nerdtree.isTabTree()
                                        let help .= "\" ". g:NERDTreeMapPreview .": preview\n"
                                    endif
                                    let help .= "\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= "\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= "\" middle-click,\n"
                                    let help .= "\" ". g:NERDTreeMapOpenSplit .": open split\n"
                                    let help .= "\" ". g:NERDTreeMapPreviewSplit .": preview split\n"
                                    let help .= "\" ". g:NERDTreeMapOpenVSplit .": open vsplit\n"
                                    let help .= "\" ". g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Directory node mappings~\n"
                                    let help .= "\" ". (g:NERDTreeMouseMode ==# 1 ? "double" : "single") ."-click,\n"
                                    let help .= "\" ". g:NERDTreeMapActivateNode .": open & close node\n"
                                    let help .= "\" ". g:NERDTreeMapOpenRecursively .": recursively open node\n"
                                    let help .= "\" ". g:NERDTreeMapCloseDir .": close parent of node\n"
                                    let help .= "\" ". g:NERDTreeMapCloseChildren .": close all child nodes of\n"
                                    let help .= "\"    current node recursively\n"
                                    let help .= "\" middle-click,\n"
                                    let help .= "\" ". g:NERDTreeMapOpenExpl.": explore selected dir\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Bookmark table mappings~\n"
                                    let help .= "\" double-click,\n"
                                    let help .= "\" ". g:NERDTreeMapActivateNode .": open bookmark\n"
                                    let help .= "\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= "\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= "\" ". g:NERDTreeMapDeleteBookmark .": delete bookmark\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Tree navigation mappings~\n"
                                    let help .= "\" ". g:NERDTreeMapJumpRoot .": go to root\n"
                                    let help .= "\" ". g:NERDTreeMapJumpParent .": go to parent\n"
                                    let help .= "\" ". g:NERDTreeMapJumpFirstChild  .": go to first child\n"
                                    let help .= "\" ". g:NERDTreeMapJumpLastChild   .": go to last child\n"
                                    let help .= "\" ". g:NERDTreeMapJumpNextSibling .": go to next sibling\n"
                                    let help .= "\" ". g:NERDTreeMapJumpPrevSibling .": go to prev sibling\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Filesystem mappings~\n"
                                    let help .= "\" ". g:NERDTreeMapChangeRoot .": change tree root to the\n"
                                    let help .= "\"    selected dir\n"
                                    let help .= "\" ". g:NERDTreeMapUpdir .": move tree root up a dir\n"
                                    let help .= "\" ". g:NERDTreeMapUpdirKeepOpen .": move tree root up a dir\n"
                                    let help .= "\"    but leave old root open\n"
                                    let help .= "\" ". g:NERDTreeMapRefresh .": refresh cursor dir\n"
                                    let help .= "\" ". g:NERDTreeMapRefreshRoot .": refresh current root\n"
                                    let help .= "\" ". g:NERDTreeMapMenu .": Show menu\n"
                                    let help .= "\" ". g:NERDTreeMapChdir .":change the CWD to the\n"
                                    let help .= "\"    selected dir\n"
                                    let help .= "\" ". g:NERDTreeMapCWD .":change tree root to CWD\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Tree filtering mappings~\n"
                                    let help .= "\" ". g:NERDTreeMapToggleHidden .": hidden files (" . (self.getShowHidden() ? "on" : "off") . ")\n"
                                    let help .= "\" ". g:NERDTreeMapToggleFilters .": file filters (" . (self.isIgnoreFilterEnabled() ? "on" : "off") . ")\n"
                                    let help .= "\" ". g:NERDTreeMapToggleFiles .": files (" . (self.getShowFiles() ? "on" : "off") . ")\n"
                                    let help .= "\" ". g:NERDTreeMapToggleBookmarks .": bookmarks (" . (self.getShowBookmarks() ? "on" : "off") . ")\n"
                            
                                    "add quickhelp entries for each custom key map
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Custom mappings~\n"
                                    for i in g:NERDTreeKeyMap.All()
                                        if !empty(i.quickhelpText)
                                            let help .= "\" ". i.key .": ". i.quickhelpText ."\n"
                                        endif
                                    endfor
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Other mappings~\n"
                                    let help .= "\" ". g:NERDTreeMapQuit .": Close the NERDTree window\n"
                                    let help .= "\" ". g:NERDTreeMapToggleZoom .": Zoom (maximize-minimize)\n"
                                    let help .= "\"    the NERDTree window\n"
                                    let help .= "\" ". g:NERDTreeMapHelp .": toggle help\n"
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Bookmark commands~\n"
                                    let help .= "\" :Bookmark [<name>]\n"
                                    let help .= "\" :BookmarkToRoot <name>\n"
                                    let help .= "\" :RevealBookmark <name>\n"
                                    let help .= "\" :OpenBookmark <name>\n"
                                    let help .= "\" :ClearBookmarks [<names>]\n"
                                    let help .= "\" :ClearAllBookmarks\n"
                                    silent! put =help
                                elseif !self.isMinimal()
    1              0.000004         let help ="\" Press ". g:NERDTreeMapHelp ." for help\n"
    1              0.000026         silent! put =help
    1              0.000001     endif

FUNCTION  231()
Called 1 time
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    1              0.000018     let newObj = copy(self)
    1              0.000002     let newObj.nerdtree = a:nerdtree
    1              0.000002     let newObj._showHelp = 0
    1              0.000001     let newObj._ignoreEnabled = 1
    1              0.000002     let newObj._showFiles = g:NERDTreeShowFiles
    1              0.000002     let newObj._showHidden = g:NERDTreeShowHidden
    1              0.000002     let newObj._showBookmarks = g:NERDTreeShowBookmarks
                            
    1              0.000001     return newObj

FUNCTION  233()
Called 1 time
Total time:   0.000451
 Self time:   0.000020

count  total (s)   self (s)
                                "if the node is the root then return the root line no.
    1   0.000380   0.000006     if a:file_node.isRoot()
    1   0.000069   0.000012         return self.getRootLineNum()
                                endif
                            
                                let totalLines = line("$")
                            
                                "the path components we have matched so far
                                let pathcomponents = [substitute(self.nerdtree.root.path.str({'format': 'UI'}), '/ *$', '', '')]
                                "the index of the component we are searching for
                                let curPathComponent = 1
                            
                                let fullpath = a:file_node.path.str({'format': 'UI'})
                            
                                let lnum = self.getRootLineNum()
                                while lnum > 0
                                    let lnum = lnum + 1
                                    "have we reached the bottom of the tree?
                                    if lnum ==# totalLines+1
                                        return -1
                                    endif
                            
                                    let curLine = getline(lnum)
                            
                                    let indent = self._indentLevelFor(curLine)
                                    if indent ==# curPathComponent
                                        let curLine = self._stripMarkup(curLine, 1)
                            
                                        let curPath =  join(pathcomponents, '/') . '/' . curLine
                                        if stridx(fullpath, curPath, 0) ==# 0
                                            if fullpath ==# curPath || strpart(fullpath, len(curPath)-1,1) ==# '/'
                                                let curLine = substitute(curLine, '/ *$', '', '')
                                                call add(pathcomponents, curLine)
                                                let curPathComponent = curPathComponent + 1
                            
                                                if fullpath ==# curPath
                                                    return lnum
                                                endif
                                            endif
                                        endif
                                    endif
                                endwhile
                                return -1

FUNCTION  234()
Called 1 time
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
    1              0.000003     let rootLine = 1
    4              0.000035     while getline(rootLine) !~# '^\(/\|<\)'
    3              0.000007         let rootLine = rootLine + 1
    3              0.000004     endwhile
    1              0.000002     return rootLine

FUNCTION  235()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000001     return self._showBookmarks

FUNCTION  236()
Called 48 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
   48              0.000049     return self._showFiles

FUNCTION  237()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000001     return self._showHelp

FUNCTION  238()
Called 48 times
Total time:   0.000062
 Self time:   0.000062

count  total (s)   self (s)
   48              0.000050     return self._showHidden

FUNCTION  gitgutter#async#execute()
Called 12 times
Total time:   0.095244
 Self time:   0.094131

count  total (s)   self (s)
   12   0.000109   0.000070   let bufnr = gitgutter#utility#bufnr()
                            
   12              0.000061   if has('nvim')
   12              0.000025     if has('unix')
   12              0.000051       let command = ["sh", "-c", a:cmd]
   12              0.000024     elseif has('win32')
                                  let command = ["cmd.exe", "/c", a:cmd]
                                else
                                  throw 'unknown os'
                                endif
                                " Make the job use a shell while avoiding (un)quoting problems.
   12              0.092470     let job_id = jobstart(command, { 'buffer':    bufnr, 'on_stdout': function('gitgutter#async#handle_diff_job_nvim'), 'on_stderr': function('gitgutter#async#handle_diff_job_nvim'), 'on_exit':   function('gitgutter#async#handle_diff_job_nvim') })
   12   0.001430   0.000590     call gitgutter#debug#log('[nvim job: '.job_id.', buffer: '.bufnr.'] '.a:cmd)
   12              0.000031     if job_id < 1
                                  throw 'diff failed'
                                endif
                            
                                " Note that when `cmd` doesn't produce any output, i.e. the diff is empty,
                                " the `stdout` event is not fired on the job handler.  Therefore we keep
                                " track of the jobs ourselves so we can spot empty diffs.
   12   0.000403   0.000168     call s:job_started(job_id)
                            
   12              0.000011   else
                                " Make the job use a shell.
                                "
                                " Pass a handler for stdout but not for stderr so that errors are
                                " ignored (and thus signs are not updated; this assumes that an error
                                " only occurs when a file is not tracked by git).
                            
                                if has('unix')
                                  let command = ["sh", "-c", a:cmd]
                                elseif has('win32')
                                  let command = "cmd.exe /c ".a:cmd
                                else
                                  throw 'unknown os'
                                endif
                            
                                let job = job_start(command, { 'out_cb':   'gitgutter#async#handle_diff_job_vim', 'close_cb': 'gitgutter#async#handle_diff_job_vim_close' })
                                call gitgutter#debug#log('[vim job: '.string(job_info(job)).', buffer: '.bufnr.'] '.a:cmd)
                            
                                call s:job_started(s:channel_id(job_getchannel(job)), bufnr)
                              endif

FUNCTION  gitgutter#utility#file_relative_to_repo_root()
Called 1 time
Total time:   0.020201
 Self time:   0.000106

count  total (s)   self (s)
    1   0.000032   0.000010   let file_path_relative_to_repo_root = gitgutter#utility#getbufvar(s:bufnr, 'repo_relative_path')
    1              0.000004   if empty(file_path_relative_to_repo_root)
    1   0.020063   0.000037     let dir_path_relative_to_repo_root = gitgutter#utility#system(gitgutter#utility#command_in_directory_of_file(g:gitgutter_git_executable.' rev-parse --show-prefix'))
    1   0.000047   0.000029     let dir_path_relative_to_repo_root = gitgutter#utility#strip_trailing_new_line(dir_path_relative_to_repo_root)
    1   0.000015   0.000008     let file_path_relative_to_repo_root = dir_path_relative_to_repo_root . gitgutter#utility#filename()
    1   0.000031   0.000010     call gitgutter#utility#setbufvar(s:bufnr, 'repo_relative_path', file_path_relative_to_repo_root)
    1              0.000001   endif
    1              0.000003   return file_path_relative_to_repo_root

FUNCTION  airline#extensions#wordcount#apply()
Called 5 times
Total time:   0.000118
 Self time:   0.000118

count  total (s)   self (s)
    5              0.000095   if match(&ft, get(g:, 'airline#extensions#wordcount#filetypes')) > -1
                                call airline#extensions#prepend_to_section('z', '%{get(b:, "airline_wordcount", "")}')
                              endif

FUNCTION  241()
Called 48 times
Total time:   0.000064
 Self time:   0.000064

count  total (s)   self (s)
   48              0.000051     return self._ignoreEnabled == 1

FUNCTION  242()
Called 3 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    3              0.000005     return g:NERDTreeMinimalUI

FUNCTION  246()
Called 1 time
Total time:   0.000209
 Self time:   0.000030

count  total (s)   self (s)
    1              0.000004     let win = winnr()
    1   0.000171   0.000006     call g:NERDTree.CursorToTreeWin()
    1              0.000003     let self._screenState = {}
    1              0.000004     let self._screenState['oldPos'] = getpos(".")
    1              0.000004     let self._screenState['oldTopLine'] = line("w0")
    1              0.000003     let self._screenState['oldWindowSize']= winwidth("")
    1   0.000018   0.000005     call nerdtree#exec(win . "wincmd w")

FUNCTION  249()
Called 1 time
Total time:   0.009043
 Self time:   0.000324

count  total (s)   self (s)
    1              0.000007     setlocal modifiable
                            
                                "remember the top line of the buffer and the current line so we can
                                "restore the view exactly how it was
    1              0.000003     let curLine = line(".")
    1              0.000003     let curCol = col(".")
    1              0.000003     let topLine = line("w0")
                            
                                "delete all lines in the buffer (being careful not to clobber a register)
    1              0.000008     silent 1,$delete _
                            
    1   0.000164   0.000007     call self._dumpHelp()
                            
                                "delete the blank line before the help and add one after it
    1   0.000006   0.000004     if !self.isMinimal()
    1              0.000005         call setline(line(".")+1, "")
    1              0.000004         call cursor(line(".")+1, col("."))
    1              0.000001     endif
                            
    1   0.000007   0.000005     if self.getShowBookmarks()
                                    call self._renderBookmarks()
                                endif
                            
                                "add the 'up a dir' line
    1   0.000004   0.000002     if !self.isMinimal()
    1   0.000010   0.000009         call setline(line(".")+1, s:UI.UpDirLine())
    1              0.000003         call cursor(line(".")+1, col("."))
    1              0.000001     endif
                            
                                "draw the header line
    1   0.000615   0.000035     let header = self.nerdtree.root.path.str({'format': 'UI', 'truncateTo': winwidth(0)})
    1              0.000029     call setline(line(".")+1, header)
    1              0.000009     call cursor(line(".")+1, col("."))
                            
                                "draw the tree
    1   0.008060   0.000085     silent put =self.nerdtree.root.renderToString()
                            
                                "delete the blank line at the top of the buffer
    1              0.000014     silent 1,1delete _
                            
                                "restore the view
    1              0.000006     let old_scrolloff=&scrolloff
    1              0.000010     let &scrolloff=0
    1              0.000005     call cursor(topLine, 1)
    1              0.000031     normal! zt
    1              0.000003     call cursor(curLine, curCol)
    1              0.000005     let &scrolloff = old_scrolloff
                            
    1              0.000006     setlocal nomodifiable

FUNCTION  gitgutter#utility#has_unsaved_changes()
Called 11 times
Total time:   0.000141
 Self time:   0.000141

count  total (s)   self (s)
   11              0.000134   return getbufvar(s:bufnr, "&mod")

FUNCTION  <SNR>102_job_started()
Called 12 times
Total time:   0.000234
 Self time:   0.000234

count  total (s)   self (s)
   12              0.000049   if a:0  " vim
                                let s:jobs[a:id] = {'output': [], 'buffer': a:1}
                              else    " nvim
   12              0.000061     let s:jobs[a:id] = 1
   12              0.000014   endif

FUNCTION  <SNR>84_create()
Called 2 times
Total time:   0.000712
 Self time:   0.000652

count  total (s)   self (s)
    2              0.000004   let _ = ''
    4              0.000014   for idx in range(len(a:parts))
    2   0.000030   0.000017     let part = airline#parts#get(a:parts[idx])
    2              0.000004     let val = ''
    2              0.000009     let add_sep = get(l:, 'add_sep', 0)
                            
    2              0.000007     if exists('part.function')
    2              0.000006       let func = (part.function).'()'
    2              0.000004     elseif exists('part.text')
                                  let func = '"'.(part.text).'"'
                                else
                                  if a:append > 0 && idx != 0
                                    let val .= s:spc.g:airline_left_alt_sep.s:spc
                                  endif
                                  if a:append < 0 && idx != 0
                                    let t = ''
                                    if !add_sep
                                      let t = s:spc.g:airline_right_alt_sep.s:spc
                                    endif
                                    let val = t.val
                                  endif
                                  if exists('part.raw')
                                    let _ .= s:wrap_accent(part, val.(part.raw))
                                    continue
                                  else
                                    let _ .= s:wrap_accent(part, val.a:parts[idx])
                                    continue
                                  endif
                                endif
                            
    2              0.000007     let minwidth = get(part, 'minwidth', 0)
                            
    2              0.000004     if a:append > 0 && idx != 0
                                  let partval = printf('%%{airline#util#append(%s,%s)}', func, minwidth)
                                  " will add an extra separator, if minwidth is zero
                                  let add_sep = (minwidth == 0)
                                elseif a:append < 0 && idx != len(a:parts) - 1
                                  let partval = printf('%%{airline#util#prepend(%s,%s)}', func, minwidth)
                                  " will add an extra separator, if minwidth is zero
                                  let add_sep = (minwidth == 0)
                                else
    2              0.000013       let partval = printf('%%{airline#util#wrap(%s,%s)}', func, minwidth)
    2              0.000004       let add_sep = 0
    2              0.000002     endif
                            
    2              0.000005     if exists('part.condition')
                                  let partval = substitute(partval, '{', '\="{".(part.condition)." ? "', '')
                                  let partval = substitute(partval, '}', ' : ""}', '')
                                endif
                            
    2   0.000071   0.000024     let val .= s:wrap_accent(part, partval)
    2              0.000006     let _ .= val
    2              0.000002   endfor
    2              0.000005   return _

FUNCTION  <SNR>89_section_is_empty()
Called 51 times
Total time:   0.000678
 Self time:   0.000678

count  total (s)   self (s)
   51              0.000094   let start=1
                            
                              " do not check for inactive windows or the tabline
   51              0.000087   if a:self._context.active == 0
   15              0.000014     return 0
                              elseif get(a:self._context, 'tabline', 0)
                                return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
   36              0.000102   if get(g:, 'airline_skip_empty_sections', 0) == 0
   36              0.000035     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              if empty(a:content)
                                return 1
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1

FUNCTION  gutentags#trace()
Called 4 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    4              0.000011    if g:gutentags_trace || (a:0 && a:1)
                                   let l:message = "gutentags: " . a:message
                                   echom l:message
                               endif

FUNCTION  <SNR>108_reset_summary()
Called 14 times
Total time:   0.000420
 Self time:   0.000146

count  total (s)   self (s)
   14   0.000412   0.000138   call gitgutter#utility#setbufvar(gitgutter#utility#bufnr(), 'summary', [0,0,0])

FUNCTION  257()
Called 1 time
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)
    1              0.000001     return '.. (up a dir)'

FUNCTION  258()
Called 24 times
Total time:   0.000315
 Self time:   0.000315

count  total (s)   self (s)
   24              0.000091     let newObj = copy(self)
   24              0.000042     let newObj.nerdtree = a:nerdtree
   24              0.000040     let newObj.subject = a:subject
   24              0.000040     let newObj.action = a:action
   24              0.000038     let newObj.params = a:params
   24              0.000024     return newObj

FUNCTION  gitgutter#hunk#reset()
Called 2 times
Total time:   0.000115
 Self time:   0.000031

count  total (s)   self (s)
    2   0.000055   0.000018   call gitgutter#utility#setbufvar(gitgutter#utility#bufnr(), 'hunks', [])
    2   0.000059   0.000011   call s:reset_summary()

FUNCTION  <SNR>80_update_hg_branch()
Called 560 times
Total time:   0.015134
 Self time:   0.015134

count  total (s)   self (s)
  560              0.000968   if s:has_lawrencium
                                let stl=lawrencium#statusline()
                                if !empty(stl) && s:has_async
                                  call s:get_mq_async('LC_ALL=C hg qtop', expand('%:p'))
                                endif
                                if exists("s:mq") && !empty(s:mq)
                                  if stl is# 'default'
                                    " Shorten default a bit
                                    let stl='def'
                                  endif
                                  let stl.=' ['.s:mq.']'
                                endif
                                let s:vcs_config['mercurial'].branch = stl
                              else
  560              0.001737     let s:vcs_config['mercurial'].branch = ''
  560              0.000506   endif

FUNCTION  gitgutter#utility#exists_file()
Called 35 times
Total time:   0.000673
 Self time:   0.000673

count  total (s)   self (s)
   35              0.000627   return filereadable(s:file)

FUNCTION  fugitive#reload_status()
Called 8 times
Total time:   0.002079
 Self time:   0.002079

count  total (s)   self (s)
    8              0.000049   if exists('s:reloading_status')
                                return
                              endif
    8              0.000013   try
    8              0.000045     let s:reloading_status = 1
    8              0.000030     let mytab = tabpagenr()
   24              0.000108     for tab in [mytab] + range(1,tabpagenr('$'))
   32              0.000125       for winnr in range(1,tabpagewinnr(tab,'$'))
   16              0.000136         if getbufvar(tabpagebuflist(tab)[winnr-1],'fugitive_type') ==# 'index'
                                      execute 'tabnext '.tab
                                      if winnr != winnr()
                                        execute winnr.'wincmd w'
                                        let restorewinnr = 1
                                      endif
                                      try
                                        if !&modified
                                          call s:BufReadIndex()
                                        endif
                                      finally
                                        if exists('restorewinnr')
                                          wincmd p
                                        endif
                                        execute 'tabnext '.mytab
                                      endtry
                                    endif
   16              0.000020       endfor
   16              0.000029     endfor
    8              0.000012   finally
    8              0.000269     unlet! s:reloading_status
    8              0.000018   endtry

FUNCTION  <SNR>80_update_branch()
Called 560 times
Total time:   0.257719
 Self time:   0.075099

count  total (s)   self (s)
  560              0.035793   let l:path = exists("*fnamemodify") ? fnamemodify(resolve(@%), ":p:h") : expand("%:p:h")
 1680              0.005906   for vcs in keys(s:vcs_config)
 1120   0.194692   0.012071     call {s:vcs_config[vcs].update_branch}(l:path)
 1120              0.005414     if b:buffer_vcs_config[vcs].branch != s:vcs_config[vcs].branch
                                  let b:buffer_vcs_config[vcs].branch = s:vcs_config[vcs].branch
                                  unlet! b:airline_head
                                endif
 1120              0.001114   endfor

FUNCTION  gitgutter#utility#is_file_buffer()
Called 35 times
Total time:   0.000320
 Self time:   0.000320

count  total (s)   self (s)
   35              0.000284   return empty(getbufvar(s:bufnr, '&buftype'))

FUNCTION  fugitive#extract_git_dir()
Called 1 time
Total time:   0.000496
 Self time:   0.000273

count  total (s)   self (s)
    1   0.000029   0.000011   if s:shellslash(a:path) =~# '^fugitive://.*//'
                                return matchstr(s:shellslash(a:path), '\C^fugitive://\zs.\{-\}\ze//')
                              endif
    1   0.000028   0.000015   let root = s:shellslash(simplify(fnamemodify(a:path, ':p:s?[\/]$??')))
    1              0.000001   let previous = ""
    2              0.000005   while root !=# previous
    2              0.000020     if root =~# '\v^//%([^/]+/?)?$'
                                  " This is for accessing network shares from Cygwin Vim. There won't be
                                  " any git directory called //.git or //serverName/.git so let's avoid
                                  " checking for them since such checks are extremely slow.
                                  break
                                endif
    2              0.000016     if index(split($GIT_CEILING_DIRECTORIES, ':'), root) >= 0
                                  break
                                endif
    2              0.000008     if root ==# $GIT_WORK_TREE && fugitive#is_git_dir($GIT_DIR)
                                  return simplify(fnamemodify(expand($GIT_DIR), ':p:s?[\/]$??'))
                                endif
    2   0.000077   0.000015     if fugitive#is_git_dir($GIT_DIR)
                                  " Ensure that we've cached the worktree
                                  call s:configured_tree(simplify(fnamemodify(expand($GIT_DIR), ':p:s?[\/]$??')))
                                  if has_key(s:dir_for_worktree, root)
                                    return s:dir_for_worktree[root]
                                  endif
                                endif
    2   0.000059   0.000023     let dir = s:sub(root, '[\/]$', '') . '/.git'
    2              0.000020     let type = getftype(dir)
    2   0.000067   0.000012     if type ==# 'dir' && fugitive#is_git_dir(dir)
    1              0.000002       return dir
                                elseif type ==# 'link' && fugitive#is_git_dir(dir)
                                  return resolve(dir)
                                elseif type !=# '' && filereadable(dir)
                                  let line = get(readfile(dir, '', 1), 0, '')
                                  if line =~# '^gitdir: \.' && fugitive#is_git_dir(root.'/'.line[8:-1])
                                    return simplify(root.'/'.line[8:-1])
                                  elseif line =~# '^gitdir: ' && fugitive#is_git_dir(line[8:-1])
                                    return line[8:-1]
                                  endif
                                elseif fugitive#is_git_dir(root)
                                  return root
                                endif
    1              0.000003     let previous = root
    1              0.000005     let root = fnamemodify(root, ':h')
    1              0.000002   endwhile
                              return ''

FUNCTION  airline#statusline()
Called 303 times
Total time:   0.007312
 Self time:   0.007312

count  total (s)   self (s)
  303              0.003104   if has_key(s:contexts, a:winnr)
  303              0.003440     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                            
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  gitgutter#utility#is_active()
Called 35 times
Total time:   0.004586
 Self time:   0.000694

count  total (s)   self (s)
   35   0.004555   0.000663   return g:gitgutter_enabled && !pumvisible() && gitgutter#utility#is_file_buffer() && gitgutter#utility#exists_file() && gitgutter#utility#not_git_dir()

FUNCTION  260()
Called 24 times
Total time:   0.001008
 Self time:   0.000382

count  total (s)   self (s)
   24   0.000466   0.000151     let event = g:NERDTreeEvent.New(a:nerdtree, a:path, a:event, a:params)
                            
   24   0.000434   0.000123     for listener in s:Notifier.GetListenersForEvent(a:event)
                                    call {listener}(event)
                                endfor

FUNCTION  261()
Called 24 times
Total time:   0.000150
 Self time:   0.000150

count  total (s)   self (s)
   24              0.000065     if !exists("s:refreshListenersMap")
    1              0.000002         let s:refreshListenersMap = {}
    1              0.000001     endif
   24              0.000027     return s:refreshListenersMap

FUNCTION  262()
Called 24 times
Total time:   0.000311
 Self time:   0.000162

count  total (s)   self (s)
   24   0.000240   0.000091     let listenersMap = s:Notifier.GetListenersMap()
   24              0.000059     return get(listenersMap, a:name, [])

FUNCTION  267()
Called 8 times
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    8              0.000036   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  airline#extensions#apply()
Called 8 times
Total time:   0.001605
 Self time:   0.000409

count  total (s)   self (s)
    8              0.000022   let s:active_winnr = winnr()
                            
    8   0.000444   0.000042   if s:is_excluded_window()
                                return -1
                              endif
                            
    8              0.000018   if &buftype == 'help'
                                call airline#extensions#apply_left_override('Help', '%f')
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
                              endif
                            
    8              0.000010   if &previewwindow
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
                              endif
                            
    8              0.000040   if has_key(s:filetype_overrides, &ft)
    2              0.000010     let args = s:filetype_overrides[&ft]
    2   0.000818   0.000024     call airline#extensions#apply_left_override(args[0], args[1])
    2              0.000002   endif
                            
    8              0.000028   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
                              endfor

FUNCTION  269()
Called 43 times
Total time:   0.000160
 Self time:   0.000160

count  total (s)   self (s)
   43              0.000145   call add(self._sections, [a:group, a:contents])

FUNCTION  gitgutter#utility#save_last_seen_change()
Called 12 times
Total time:   0.000362
 Self time:   0.000153

count  total (s)   self (s)
   12   0.000353   0.000144   call gitgutter#utility#setbufvar(s:bufnr, 'last_tick', getbufvar(s:bufnr, 'changedtick'))

FUNCTION  ale#cursor#EchoCursorWarning()
Called 191 times
Total time:   0.025519
 Self time:   0.011452

count  total (s)   self (s)
                                " Only echo the warnings in normal mode, otherwise we will get problems.
  191              0.002418     if mode() !=# 'n'
                                    return
                                endif
                            
  191   0.016811   0.002744     let [l:info, l:loc] = s:FindItemAtCursor()
                            
  191              0.000537     if !empty(l:loc)
                                    let l:msg = s:GetMessage(l:loc.linter_name, l:loc.type, l:loc.text)
                                    call ale#cursor#TruncatedEcho(l:msg)
                                    let l:info.echoed = 1
                                elseif get(l:info, 'echoed')
                                    " We'll only clear the echoed message when moving off errors once,
                                    " so we don't continually clear the echo line.
                                    echo
                                    let l:info.echoed = 0
                                endif

FUNCTION  <SNR>90_build_sections()
Called 12 times
Total time:   0.003171
 Self time:   0.000640

count  total (s)   self (s)
   62              0.000078   for key in a:keys
   50              0.000131     if (key == 'warning' || key == 'error') && !a:context.active
    6              0.000006       continue
                                endif
   44   0.002740   0.000208     call s:add_section(a:builder, a:context, key)
   44              0.000035   endfor

FUNCTION  provider#clipboard#Call()
Called 2 times
Total time:   0.269455
 Self time:   0.000061

count  total (s)   self (s)
    2   0.269452   0.000058   return call(s:clipboard[a:method],a:args,s:clipboard)

FUNCTION  gitgutter#diff#parse_diff()
Called 12 times
Total time:   0.001928
 Self time:   0.000827

count  total (s)   self (s)
   12              0.000033   let hunks = []
   36              0.000192   for line in split(a:diff, '\n')
   24   0.001348   0.000247     let hunk_info = gitgutter#diff#parse_hunk(line)
   24              0.000064     if len(hunk_info) == 4
   12              0.000044       call add(hunks, hunk_info)
   12              0.000015     endif
   24              0.000025   endfor
   12              0.000020   return hunks

FUNCTION  airline#util#shorten()
Called 566 times
Total time:   0.023654
 Self time:   0.023654

count  total (s)   self (s)
  566              0.012270   if winwidth(0) < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
  280              0.000760     if get(a:000, 0, 0)
                                  " shorten from tail
                                  return '…'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
  280              0.004392       return matchstr(a:text, '^.\{'.a:minwidth.'}').'…'
                                endif
                              else
  286              0.000433     return a:text
                              endif

FUNCTION  271()
Called 8 times
Total time:   0.035512
 Self time:   0.005263

count  total (s)   self (s)
    8              0.000012   let side = 1
    8              0.000010   let line = ''
    8              0.000010   let i = 0
    8              0.000019   let length = len(self._sections)
    8              0.000011   let split = 0
    8              0.000011   let is_empty = 0
    8              0.000012   let prev_group = ''
                            
   59              0.000101   while i < length
   51              0.000123     let section = self._sections[i]
   51              0.000104     let group = section[0]
   51              0.000132     let contents = section[1]
   51              0.000089     let pgroup = prev_group
   51   0.000963   0.000314     let prev_group = s:get_prev_group(self._sections, i)
   51              0.000182     if group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let group = 'airline_c'. self._context.bufnr
                                elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let prev_group = 'airline_c'. self._context.bufnr
                                endif
   51              0.000053     if is_empty
                                  let prev_group = pgroup
                                endif
   51   0.000979   0.000301     let is_empty = s:section_is_empty(self, contents)
                            
   51              0.000053     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
                                endif
                            
   51              0.000076     if group == ''
                                  let line .= contents
                                elseif group == '|'
    8              0.000010       let side = 0
    8              0.000019       let line .= contents
    8              0.000009       let split = 1
    8              0.000006     else
   43              0.000064       if prev_group == ''
    8              0.000028         let line .= '%#'.group.'#'
    8              0.000008       elseif split
    7              0.000007         if !is_empty
    7   0.003266   0.000052           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
    7              0.000006         endif
    7              0.000010         let split = 0
    7              0.000006       else
   28              0.000033         if !is_empty
   28   0.023535   0.000270           let line .= s:get_seperator(self, prev_group, group, side)
   28              0.000028         endif
   28              0.000021       endif
   43   0.002889   0.000447       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
   43              0.000039     endif
                            
   51              0.000093     let i = i + 1
   51              0.000058   endwhile
                            
    8              0.000015   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
    3              0.000121     let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
    3              0.000003   endif
    8              0.000013   return line

FUNCTION  275()
Called 2 times
Total time:   0.269394
 Self time:   0.000109

count  total (s)   self (s)
    2              0.000012   if a:reg == '"'
                                call s:clipboard.set(a:lines,a:regtype,'+')
                                if s:copy['*'] != s:copy['+']
                                  call s:clipboard.set(a:lines,a:regtype,'*')
                                end
                                return 0
                              end
    2              0.000004   if s:cache_enabled == 0
    2   0.269341   0.000056     call s:try_cmd(s:copy[a:reg], a:lines)
    2              0.000009     return 0
                              end
                            
                              let selection = s:selections[a:reg]
                              if selection.owner > 0
                                " The previous provider instance should exit when the new one takes
                                " ownership, but kill it to be sure we don't fill up the job table.
                                call jobstop(selection.owner)
                              end
                              let selection.data = [a:lines, a:regtype]
                              let argv = split(s:copy[a:reg], " ")
                              let selection.detach = s:cache_enabled
                              let selection.cwd = "/"
                              let jobid = jobstart(argv, selection)
                              if jobid <= 0
                                echohl WarningMsg
                                echo "clipboard: error when invoking provider"
                                echohl None
                                return 0
                              endif
                              call jobsend(jobid, a:lines)
                              call jobclose(jobid, 'stdin')
                              let selection.owner = jobid

FUNCTION  <SNR>42_airline_toggle()
Called 2 times
Total time:   0.007866
 Self time:   0.001493

count  total (s)   self (s)
    2              0.000033   if exists("#airline")
    1              0.000003     augroup airline
    1              0.000906       au!
    1              0.000006     augroup END
    1              0.000039     augroup! airline
                            
    1              0.000007     if exists("s:stl")
    1              0.000012       let &stl = s:stl
    1              0.000001     endif
                            
    1   0.000075   0.000067     silent doautocmd User AirlineToggledOff
    1              0.000002   else
    1              0.000009     let s:stl = &statusline
    1              0.000005     augroup airline
    1              0.000199       autocmd!
                            
    1              0.000015       autocmd CmdwinEnter * call airline#add_statusline_func('airline#cmdwinenter') | call <sid>on_window_changed()
    1              0.000004       autocmd CmdwinLeave * call airline#remove_statusline_func('airline#cmdwinenter')
                            
    1              0.000005       autocmd GUIEnter,ColorScheme * call <sid>on_colorscheme_changed()
    1              0.000016       autocmd VimEnter,WinEnter,BufWinEnter,FileType,BufUnload * call <sid>on_window_changed()
    1              0.000005       if exists('#CompleteDone')
                                    autocmd CompleteDone * call <sid>on_window_changed()
                                  endif
                            
    1              0.000004       autocmd VimResized * unlet! w:airline_lastmode | :call <sid>airline_refresh()
    1              0.000005       autocmd TabEnter * :unlet! w:airline_lastmode | let w:airline_active=1
    1              0.000009       autocmd BufWritePost */autoload/airline/themes/*.vim exec 'source '.split(globpath(&rtp, 'autoload/airline/themes/'.g:airline_theme.'.vim', 1), "\n")[0] | call airline#load_theme()
    1              0.000001     augroup END
                            
    1              0.000002     if s:airline_initialized
    1   0.006372   0.000014       call s:on_window_changed()
    1              0.000001     endif
                            
    1   0.000054   0.000048     silent doautocmd User AirlineToggledOn
    1              0.000001   endif

FUNCTION  airline#highlighter#highlight_modified_inactive()
Called 13 times
Total time:   0.002296
 Self time:   0.000478

count  total (s)   self (s)
   13              0.000066   if getbufvar(a:bufnr, '&modified')
    7              0.000077     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
    7              0.000008   else
    6              0.000074     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    6              0.000005   endif
                            
   13              0.000029   if !empty(colors)
    6   0.001908   0.000090     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
    6              0.000007   endif

FUNCTION  airline#extensions#branch#get_head()
Called 280 times
Total time:   0.169563
 Self time:   0.007443

count  total (s)   self (s)
  280   0.163902   0.001781   let head = airline#extensions#branch#head()
  280              0.001407   let empty_message = get(g:, 'airline#extensions#branch#empty_message', '')
  280              0.001433   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
  280              0.002372   return empty(head) ? empty_message : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  gitgutter#utility#using_xolox_shell()
Called 13 times
Total time:   0.000308
 Self time:   0.000308

count  total (s)   self (s)
   13              0.000037   if s:using_xolox_shell == -1
                                if !g:gitgutter_avoid_cmd_prompt_on_windows
                                  let s:using_xolox_shell = 0
                                " Although xolox/vim-shell works on both windows and unix we only want to use
                                " it on windows.
                                elseif has('win32') || has('win64') || has('win32unix')
                                  let s:using_xolox_shell = exists('g:xolox#misc#version') && exists('g:xolox#shell#version')
                                else
                                  let s:using_xolox_shell = 0
                                endif
                              endif
   13              0.000024   return s:using_xolox_shell

FUNCTION  fugitive#head()
Called 560 times
Total time:   0.133558
 Self time:   0.011053

count  total (s)   self (s)
  560              0.002087   if !exists('b:git_dir')
                                return ''
                              endif
                            
  560   0.129632   0.007127   return s:repo().head(a:0 ? a:1 : 0)

FUNCTION  <SNR>82_ws_refresh()
Called 12 times
Total time:   0.000168
 Self time:   0.000168

count  total (s)   self (s)
   12              0.000050   unlet! b:airline_whitespace_check
   12              0.000059   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh'
                              endif

FUNCTION  <SNR>88_system_job_handler()
Called 2 times
Total time:   0.000090
 Self time:   0.000090

count  total (s)   self (s)
    2              0.000031     if a:event == 'stdout'
    2              0.000034       let self.buf .=  join(a:data)
    2              0.000005     endif

FUNCTION  airline#extensions#hunks#get_hunks()
Called 280 times
Total time:   1.851167
 Self time:   0.027959

count  total (s)   self (s)
  280              0.000981   if !get(w:, 'airline_active', 0)
                                return ''
                              endif
                              " Cache vavlues, so that it isn't called too often
  280              0.004481   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == changenr() && winwidth(0) == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty'
                                return b:airline_hunks
                              endif
  280   1.825079   0.001871   let hunks = s:get_hunks()
  280              0.000531   let string = ''
  280              0.000618   if !empty(hunks)
 1120              0.001907     for i in [0, 1, 2]
  840              0.003313       if (s:non_zero_only == 0 && winwidth(0) > 100) || hunks[i] > 0
  560              0.003687         let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
  560              0.000537       endif
  840              0.000914     endfor
  280              0.000245   endif
  280              0.000732   let b:airline_hunks = string
  280              0.000804   let b:airline_changenr = changenr()
  280              0.000967   let s:airline_winwidth = winwidth(0)
  280              0.000508   return string

FUNCTION  <SNR>84_wrap_accent()
Called 2 times
Total time:   0.000047
 Self time:   0.000039

count  total (s)   self (s)
    2              0.000008   if exists('a:part.accent')
    2   0.000026   0.000017     call airline#highlighter#add_accent(a:part.accent)
    2              0.000011     return '%#__accent_'.(a:part.accent).'#'.a:value.'%#__restore__#'
                              endif
                              return a:value

FUNCTION  <SNR>42_on_window_changed()
Called 9 times
Total time:   0.043577
 Self time:   0.000407

count  total (s)   self (s)
    9              0.000030   if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
                                return
                              endif
                              " Handle each window only once, since we might come here several times for
                              " different autocommands.
    9              0.000124   let l:key = [bufnr('%'), winnr(), winnr('$'), tabpagenr(), &ft]
    9              0.000100   if get(g:, 'airline_last_window_changed', []) == l:key && &stl is# '%!airline#statusline('.winnr().')' && &ft !~? 'gitcommit'
                                " fugitive is special, it changes names and filetypes several times,
                                " make sure the caching does not get into its way
    4              0.000004     return
                              endif
    5              0.000026   let g:airline_last_window_changed = l:key
    5   0.000044   0.000028   call s:init()
    5   0.043188   0.000033   call airline#update_statusline()

FUNCTION  <SNR>110_StopPreviousJobs()
Called 15 times
Total time:   0.000621
 Self time:   0.000621

count  total (s)   self (s)
   15              0.000055     if !has_key(g:ale_buffer_info, a:buffer)
                                    " Do nothing if we didn't run anything for the buffer.
                                    return
                                endif
                            
   15              0.000035     let l:new_job_list = []
                            
   15              0.000058     for l:job in g:ale_buffer_info[a:buffer].job_list
                                    let l:job_id = s:GetJobID(l:job)
                            
                                    if has_key(s:job_info_map, l:job_id)&& s:job_info_map[l:job_id].linter.name ==# a:linter.name
                                        " Stop jobs which match the buffer and linter.
                                        call ale#engine#ClearJob(l:job)
                                    else
                                        " Keep other jobs in the list.
                                        call add(l:new_job_list, l:job)
                                    endif
                                endfor
                            
                                " Update the list, removing the previously run job.
   15              0.000062     let g:ale_buffer_info[a:buffer].job_list = l:new_job_list

FUNCTION  <SNR>82_check_mixed_indent()
Called 8 times
Total time:   0.002702
 Self time:   0.002702

count  total (s)   self (s)
    8              0.000018   if s:indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less than tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
                              elseif s:indent_algo == 2
                                return search('\v(^\t* +\t\s*\S)', 'nw')
                              else
    8              0.002573     return search('\v(^\t+ +)|(^ +\t+)', 'nw')
                              endif

FUNCTION  gitgutter#utility#getbufvar()
Called 396 times
Total time:   0.006893
 Self time:   0.006893

count  total (s)   self (s)
  396              0.004009   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
  396              0.001325   if has_key(dict, a:varname)
  395              0.001005     return dict[a:varname]
                              else
    1              0.000002     if a:0
                                  return a:1
                                endif
    1              0.000001   endif

FUNCTION  <SNR>96_write_triggered_update_tags()
Called 2 times
Total time:   0.000356
 Self time:   0.000167

count  total (s)   self (s)
    2              0.000007     if g:gutentags_enabled && g:gutentags_generate_on_write
    4              0.000013         for module in g:gutentags_modules
    2   0.000208   0.000029             call s:update_tags(a:bufno, module, 0, 2)
    2              0.000002         endfor
    2              0.000002     endif
    2   0.000108   0.000099     silent doautocmd User GutentagsUpdated

FUNCTION  gitgutter#diff#is_removed()
Called 12 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
   12              0.000031   return a:from_count > 0 && a:to_count == 0

FUNCTION  ale#cursor#EchoCursorWarningWithDelay()
Called 208 times
Total time:   0.034718
 Self time:   0.011252

count  total (s)   self (s)
  208   0.023157   0.002582     if ale#ShouldDoNothing()
    1              0.000001         return
                                endif
                            
  207   0.004517   0.001626     call s:StopCursorTimer()
                            
  207              0.001559     let l:pos = getcurpos()[0:2]
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
  207              0.000675     if l:pos != s:last_pos
  196              0.000759         let s:last_pos = l:pos
  196              0.001604         let s:cursor_timer = timer_start(10, function('ale#cursor#EchoCursorWarning'))
  196              0.000247     endif

FUNCTION  airline#extensions#ale#get_errors()
Called 280 times
Total time:   0.017711
 Self time:   0.002538

count  total (s)   self (s)
  280   0.016916   0.001744   let l:count = s:count(0)
  280              0.000577   return l:count ? s:error_symbol . l:count : ''

FUNCTION  gitgutter#handle_diff()
Called 12 times
Total time:   0.044902
 Self time:   0.001226

count  total (s)   self (s)
   12   0.000673   0.000084   call gitgutter#debug#log(a:diff)
                            
   12   0.000592   0.000316   call gitgutter#utility#setbufvar(gitgutter#utility#bufnr(), 'tracked', 1)
                            
   12   0.002952   0.000188   call gitgutter#hunk#set_hunks(gitgutter#diff#parse_diff(a:diff))
   12   0.006415   0.000175   let modified_lines = gitgutter#diff#process_hunks(gitgutter#hunk#hunks())
                            
   12              0.000042   if len(modified_lines) > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once('exceeded maximum number of signs (configured by g:gitgutter_max_signs).', 'max_signs')
                                call gitgutter#sign#clear_signs()
                                return
                              endif
                            
   12              0.000030   if g:gitgutter_signs || g:gitgutter_highlight_lines
   12   0.033575   0.000132     call gitgutter#sign#update_signs(modified_lines)
   12              0.000013   endif
                            
   12   0.000445   0.000082   call gitgutter#utility#save_last_seen_change()

FUNCTION  <SNR>42_init()
Called 5 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    5              0.000007   if s:airline_initialized
    5              0.000004     return
                              endif
                              let s:airline_initialized = 1
                            
                              call airline#extensions#load()
                              call airline#init#sections()
                            
                              let s:theme_in_vimrc = exists('g:airline_theme')
                              if s:theme_in_vimrc
                                try
                                  let palette = g:airline#themes#{g:airline_theme}#palette
                                catch
                                  echom 'Could not resolve airline theme "' . g:airline_theme . '". Themes have been migrated to github.com/vim-airline/vim-airline-themes.'
                                  let g:airline_theme = 'dark'
                                endtry
                                silent call airline#switch_theme(g:airline_theme)
                              else
                                let g:airline_theme = 'dark'
                                silent call s:on_colorscheme_changed()
                              endif
                            
                              silent doautocmd User AirlineAfterInit

FUNCTION  <SNR>79_get_hunks_gitgutter()
Called 280 times
Total time:   1.813640
 Self time:   0.004735

count  total (s)   self (s)
  280   1.802803   0.002348   if !get(g:, 'gitgutter_enabled', 0) || s:is_branch_empty()
                                return ''
                              endif
  280   0.009971   0.001520   return GitGutterGetHunkSummary()

FUNCTION  gitgutter#diff#process_hunks()
Called 12 times
Total time:   0.005969
 Self time:   0.000354

count  total (s)   self (s)
   12              0.000033   let modified_lines = []
   24              0.000049   for hunk in a:hunks
   12   0.005771   0.000156     call extend(modified_lines, gitgutter#diff#process_hunk(hunk))
   12              0.000015   endfor
   12              0.000021   return modified_lines

FUNCTION  <SNR>82_check_mixed_indent_file()
Called 8 times
Total time:   0.000934
 Self time:   0.000934

count  total (s)   self (s)
    8              0.000045   if index(s:c_like_langs, &ft) > -1
                                " for C-like languages: allow /** */ comment style with one space before the '*'
                                let head_spc = '\v(^ +\*@!)'
                              else
    8              0.000014     let head_spc = '\v(^ +)'
    8              0.000007   endif
    8              0.000200   let indent_tabs = search('\v(^\t+)', 'nw')
    8              0.000566   let indent_spc  = search(head_spc, 'nw')
    8              0.000019   if indent_tabs > 0 && indent_spc > 0
                                return printf("%d:%d", indent_tabs, indent_spc)
                              else
    8              0.000009     return ''
                              endif

FUNCTION  <SNR>40_buffer_type()
Called 2 times
Total time:   0.000710
 Self time:   0.000318

count  total (s)   self (s)
    2   0.000026   0.000016   if self.getvar('fugitive_type') != ''
                                let type = self.getvar('fugitive_type')
                              elseif fnamemodify(self.spec(),':p') =~# '.\git/refs/\|\.git/\w*HEAD$'
                                let type = 'head'
                              elseif self.getline(1) =~ '^tree \x\{40\}$' && self.getline(2) == ''
                                let type = 'tree'
                              elseif self.getline(1) =~ '^\d\{6\} \w\{4\} \x\{40\}\>\t'
                                let type = 'tree'
                              elseif self.getline(1) =~ '^\d\{6\} \x\{40\}\> \d\t'
                                let type = 'index'
                              elseif isdirectory(self.spec())
                                let type = 'directory'
                              elseif self.spec() == ''
                                let type = 'null'
                              else
    2              0.000005     let type = 'file'
    2              0.000003   endif
    2              0.000003   if a:0
    2              0.000028     return !empty(filter(copy(a:000),'v:val ==# type'))
                              else
                                return type
                              endif

FUNCTION  <SNR>89_get_accented_line()
Called 43 times
Total time:   0.002442
 Self time:   0.002442

count  total (s)   self (s)
   43              0.000074   if a:self._context.active
   31              0.000055     let contents = []
   31              0.000271     let content_parts = split(a:contents, '__accent')
   62              0.000119     for cpart in content_parts
   31              0.000350       let accent = matchstr(cpart, '_\zs[^#]*\ze')
   31              0.000100       call add(contents, cpart)
   31              0.000032     endfor
   31              0.000139     let line = join(contents, a:group)
   31              0.000254     let line = substitute(line, '__restore__', a:group, 'g')
   31              0.000030   else
   12              0.000200     let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
   12              0.000091     let line = substitute(line, '%#__restore__#', '', 'g')
   12              0.000011   endif
   43              0.000057   return line

FUNCTION  gitgutter#hunk#set_hunks()
Called 12 times
Total time:   0.000837
 Self time:   0.000202

count  total (s)   self (s)
   12   0.000382   0.000119   call gitgutter#utility#setbufvar(gitgutter#utility#bufnr(), 'hunks', a:hunks)
   12   0.000443   0.000071   call s:reset_summary()

FUNCTION  airline#builder#new()
Called 8 times
Total time:   0.000240
 Self time:   0.000240

count  total (s)   self (s)
    8              0.000047   let builder = copy(s:prototype)
    8              0.000018   let builder._context = a:context
    8              0.000014   let builder._sections = []
                            
    8              0.000133   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
    8              0.000011   return builder

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
  560   1.959160   0.017289  airline#extensions#branch#head()
  280   1.851167   0.027959  airline#extensions#hunks#get_hunks()
  280   1.823208   0.009568  <SNR>79_get_hunks()
  280   1.813640   0.004735  <SNR>79_get_hunks_gitgutter()
  280   1.800454   0.003414  <SNR>79_is_branch_empty()
  560   1.683760   0.060286  <SNR>80_update_untracked()
    4   1.605044   1.604954  airline#util#system()
  303   0.270256   0.044590  airline#check_mode()
    2   0.269455   0.000061  provider#clipboard#Call()
    2   0.269394   0.000109  275()
    2   0.269285             <SNR>106_try_cmd()
  560   0.257719   0.075099  <SNR>80_update_branch()
   13   0.223370   0.033846  airline#highlighter#highlight()
  280   0.169563   0.007443  airline#extensions#branch#get_head()
  710   0.168785   0.052830  airline#highlighter#exec()
  560   0.167487   0.033929  <SNR>80_update_git_branch()
   23   0.152312   0.004039  gitgutter#process_buffer()
   12   0.140838   0.022285  gitgutter#diff#run_diff()
  560   0.133558   0.011053  fugitive#head()
 1028   0.113111   0.035368  airline#highlighter#get_highlight()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    4   1.605044   1.604954  airline#util#system()
    2              0.269285  <SNR>106_try_cmd()
   12   0.095244   0.094131  gitgutter#async#execute()
  560   0.257719   0.075099  <SNR>80_update_branch()
 2056              0.069435  <SNR>85_get_syn()
  560   1.683760   0.060286  <SNR>80_update_untracked()
  710   0.168785   0.052830  airline#highlighter#exec()
  303   0.270256   0.044590  airline#check_mode()
 1120              0.039099  <SNR>40_repo()
 1028   0.113111   0.035368  airline#highlighter#get_highlight()
  560   0.167487   0.033929  <SNR>80_update_git_branch()
   13   0.223370   0.033846  airline#highlighter#highlight()
  560   0.041870   0.032552  <SNR>40_repo_head_ref()
  280   0.051763   0.030768  airline#extensions#whitespace#check()
  560   0.100369   0.030270  <SNR>40_repo_head()
  280   1.851167   0.027959  airline#extensions#hunks#get_hunks()
 3591              0.027046  <SNR>85_Get()
  232              0.025502  <SNR>52_Highlight_Matching_Pair()
  566              0.023654  airline#util#shorten()
   12   0.140838   0.022285  gitgutter#diff#run_diff()

